
// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=flipBit_cc971e4a99
ROOST_METHOD_SIG_HASH=flipBit_219935ae9f

"""
Scenario 1: Test to flip a middle bit in a binary number

Details:  
  TestName: testFlipMiddleBit
  Description: This test is meant to check the flipBit method by flipping a bit in the middle of a binary number. 
Execution:
  Arrange: Initialize an int number with a binary representation where a middle bit is 0.
  Act: Invoke the flipBit method with the number and the bit position to flip as parameters.
  Assert: The returned result should be the binary representation of the number with the middle bit flipped to 1.
Validation: 
  The assertion verifies that the flipBit method correctly flips a middle bit in a binary number. It is significant as it ensures that the method works correctly for typical use cases.

Scenario 2: Test to flip the least significant bit in a binary number

Details:  
  TestName: testFlipLeastSignificantBit
  Description: This test is meant to check the flipBit method by flipping the least significant bit in a binary number. 
Execution:
  Arrange: Initialize an int number with a binary representation where the least significant bit is 0.
  Act: Invoke the flipBit method with the number and 0 as parameters.
  Assert: The returned result should be the binary representation of the number with the least significant bit flipped to 1.
Validation: 
  The assertion verifies that the flipBit method correctly flips the least significant bit in a binary number. This test is significant as it tests the method's behavior for edge cases.

Scenario 3: Test to flip the most significant bit in a binary number

Details:  
  TestName: testFlipMostSignificantBit
  Description: This test is meant to check the flipBit method by flipping the most significant bit in a binary number. 
Execution:
  Arrange: Initialize an int number with a binary representation where the most significant bit is 0.
  Act: Invoke the flipBit method with the number and the position of the most significant bit as parameters.
  Assert: The returned result should be the binary representation of the number with the most significant bit flipped to 1.
Validation: 
  The assertion verifies that the flipBit method correctly flips the most significant bit in a binary number. This test is significant as it checks the method's operation for edge cases.

Scenario 4: Test to flip a non-existent bit in a binary number

Details:  
  TestName: testFlipNonExistentBit
  Description: This test is meant to check the flipBit method's behavior when trying to flip a non-existent bit in a binary number. 
Execution:
  Arrange: Initialize an int number with a binary representation.
  Act: Invoke the flipBit method with the number and a bit position that doesn't exist in the binary representation as parameters.
  Assert: The returned result should be the same as the original number.
Validation: 
  The assertion verifies that the flipBit method correctly handles the case when trying to flip a non-existent bit. This test is significant as it checks the method's error handling.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class SingleBitOperationsFlipBitTest {
    @Test
    @Tag("valid")
    public void testFlipMiddleBit() {
        int num = 0b10100; // 20 in decimal
        int bitPosition = 2;
        int expected = 0b10110; // 22 in decimal
        int result = SingleBitOperations.flipBit(num, bitPosition);
        assertEquals(expected, result, "Bit flip did not work correctly");
    }
    @Test
    @Tag("boundary")
    public void testFlipLeastSignificantBit() {
        int num = 0b10100; // 20 in decimal
        int bitPosition = 0;
        int expected = 0b10101; // 21 in decimal
        int result = SingleBitOperations.flipBit(num, bitPosition);
        assertEquals(expected, result, "Bit flip did not work correctly");
    }
    @Test
    @Tag("boundary")
    public void testFlipMostSignificantBit() {
        int num = 0b10100; // 20 in decimal
        int bitPosition = 4;
        int expected = 0b00100; // 4 in decimal
        int result = SingleBitOperations.flipBit(num, bitPosition);
        assertEquals(expected, result, "Bit flip did not work correctly");
    }
    @Test
    @Tag("invalid")
    public void testFlipNonExistentBit() {
        int num = 0b10100; // 20 in decimal
        int bitPosition = 5; // non-existent bit position
        int expected = num; // should remain the same
        int result = SingleBitOperations.flipBit(num, bitPosition);
        assertEquals(expected, result, "Bit flip did not work correctly");
    }
}