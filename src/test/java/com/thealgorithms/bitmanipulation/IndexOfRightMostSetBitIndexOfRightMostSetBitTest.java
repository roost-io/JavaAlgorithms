

// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=indexOfRightMostSetBit_59025c195c
ROOST_METHOD_SIG_HASH=indexOfRightMostSetBit_05d26edc31

"""
Scenario 1: Testing the method with a positive number having set bits
Details:  
  TestName: testPositiveNumberWithSetBits
  Description: This test aims to check the functionality of the method when a positive integer with set bits is passed as an argument. 
Execution:
  Arrange: No specific arrangement needed as we are providing direct integer inputs.
  Act: Invoke the method indexOfRightMostSetBit with a positive number (for example, 18).
  Assert: Use JUnit assertions to compare the actual return value against the expected outcome (1 in this case).
Validation: 
  The assertion verifies that the method correctly identifies the index of the rightmost set bit in the binary representation of a positive number. This is crucial for binary operations and manipulations.

Scenario 2: Testing the method with a negative number having set bits
Details:  
  TestName: testNegativeNumberWithSetBits
  Description: This test checks the method's functionality when a negative integer with set bits is passed as an argument. 
Execution:
  Arrange: No specific arrangement needed as we are providing direct integer inputs.
  Act: Invoke the method indexOfRightMostSetBit with a negative number (for example, -18).
  Assert: Use JUnit assertions to compare the actual return value against the expected outcome (1 in this case).
Validation: 
  The assertion verifies that the method correctly identifies the index of the rightmost set bit in the binary representation of a negative number. This is crucial for binary operations and manipulations.

Scenario 3: Testing the method with zero
Details:  
  TestName: testZero
  Description: This test checks the method's behavior when zero is passed as an argument. 
Execution:
  Arrange: No specific arrangement needed as we are providing direct integer inputs.
  Act: Invoke the method indexOfRightMostSetBit with 0.
  Assert: Use JUnit assertions to compare the actual return value against the expected outcome (-1 in this case).
Validation: 
  The assertion verifies that the method correctly returns -1 when there are no set bits (i.e., when the input is zero). This is crucial for ensuring the method's correctness and stability.

Scenario 4: Testing the method with a large positive number
Details:  
  TestName: testLargePositiveNumber
  Description: This test checks the method's behavior when a large positive number is passed as an argument. 
Execution:
  Arrange: No specific arrangement needed as we are providing direct integer inputs.
  Act: Invoke the method indexOfRightMostSetBit with a large positive number (for example, 1000000000).
  Assert: Use JUnit assertions to compare the actual return value against the expected outcome.
Validation: 
  The assertion verifies that the method can handle and correctly process large positive numbers. This is important for ensuring the scalability and robustness of the method.

Scenario 5: Testing the method with a large negative number
Details:  
  TestName: testLargeNegativeNumber
  Description: This test checks the method's behavior when a large negative number is passed as an argument. 
Execution:
  Arrange: No specific arrangement needed as we are providing direct integer inputs.
  Act: Invoke the method indexOfRightMostSetBit with a large negative number (for example, -1000000000).
  Assert: Use JUnit assertions to compare the actual return value against the expected outcome.
Validation: 
  The assertion verifies that the method can handle and correctly process large negative numbers. This is important for ensuring the scalability and robustness of the method.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class IndexOfRightMostSetBitIndexOfRightMostSetBitTest {
  @Test
  @Tag("valid")
  public void testPositiveNumberWithSetBits() {
    int n = 18;
    int expected = 1;
    int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
    assertEquals(expected, actual);
  }
  @Test
  @Tag("valid")
  public void testNegativeNumberWithSetBits() {
    int n = -18;
    int expected = 1;
    int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
    assertEquals(expected, actual);
  }
  @Test
  @Tag("boundary")
  public void testZero() {
    int n = 0;
    int expected = -1;
    int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
    assertEquals(expected, actual);
  }
  @Test
  @Tag("valid")
  public void testLargePositiveNumber() {
    int n = 1000000000;
    int expected = 0;
    int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
    assertEquals(expected, actual);
  }
  @Test
  @Tag("valid")
  public void testLargeNegativeNumber() {
    int n = -1000000000;
    int expected = 0;
    int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
    assertEquals(expected, actual);
  }
}