

// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=reverseBits_6cf3d3ef63
ROOST_METHOD_SIG_HASH=reverseBits_b886113125

"""
  Scenario 1: Test Reverse Bits for a positive number

  Details:  
    TestName: testReverseBitsForPositiveNumber
    Description: This test is meant to check the output of the reverseBits method when a positive number is passed as parameter. 
  Execution:
    Arrange: Initialize the input as a positive number. 
    Act: Invoke the reverseBits method with the initialized positive number. 
    Assert: Use JUnit assertions to check if the reversed bits of the positive number are as expected.
  Validation: 
    This assertion aims to verify that the reverseBits method correctly reverses the bits of a positive number. The expected result is based on the binary representation of the positive number. This test is significant as it verifies the basic functionality of the reverseBits method.

  Scenario 2: Test Reverse Bits for a negative number

  Details:  
    TestName: testReverseBitsForNegativeNumber
    Description: This test is meant to check the output of the reverseBits method when a negative number is passed as parameter. 
  Execution:
    Arrange: Initialize the input as a negative number. 
    Act: Invoke the reverseBits method with the initialized negative number. 
    Assert: Use JUnit assertions to check if the reversed bits of the negative number are as expected.
  Validation: 
    This assertion aims to verify that the reverseBits method correctly reverses the bits of a negative number. The expected result is based on the binary representation of the negative number. This test is significant as it verifies the functionality of the reverseBits method for negative numbers.

  Scenario 3: Test Reverse Bits for zero

  Details:  
    TestName: testReverseBitsForZero
    Description: This test is meant to check the output of the reverseBits method when zero is passed as parameter. 
  Execution:
    Arrange: Initialize the input as zero. 
    Act: Invoke the reverseBits method with zero. 
    Assert: Use JUnit assertions to check if the reversed bits of zero is zero.
  Validation: 
    This assertion aims to verify that the reverseBits method correctly reverses the bits of zero. The expected result is zero as reversing the bits of zero should still yield zero. This test is significant as it verifies the functionality of the reverseBits method for zero.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class ReverseBitsReverseBitsTest {
    @Test
    @Tag("valid")
    public void testReverseBitsForPositiveNumber() {
        int input = 43261596; // Binary representation: 00000010100101000001111010011100
        int expectedOutput = -1952257792; // Binary representation: 00111001011110000010100101000000
        assertEquals(expectedOutput, ReverseBits.reverseBits(input));
    }
    @Test
    @Tag("valid")
    public void testReverseBitsForNegativeNumber() {
        int input = -3; // Binary representation: 11111111111111111111111111111101
        int expectedOutput = -1073741825; // Binary representation: 10111111111111111111111111111111
        assertEquals(expectedOutput, ReverseBits.reverseBits(input));
    }
    @Test
    @Tag("boundary")
    public void testReverseBitsForZero() {
        int input = 0; // Binary representation: 00000000000000000000000000000000
        int expectedOutput = 0; // Binary representation: 00000000000000000000000000000000
        assertEquals(expectedOutput, ReverseBits.reverseBits(input));
    }
}