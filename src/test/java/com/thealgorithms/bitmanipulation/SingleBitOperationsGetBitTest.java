
// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=getBit_487c75a4b3
ROOST_METHOD_SIG_HASH=getBit_2ea30e777d

Scenario 1: Validating the Bit Value at a Given Position in a Positive Integer

Details:  
TestName: validateBitValueInPositiveInteger
Description: This test is meant to check the correct bit value at a given position in a positive integer number. 
Execution:
Arrange: A positive integer number and a bit position are provided.
Act: Invoke the getBit method with the positive integer number and bit position.
Assert: Use JUnit assertions to compare the actual bit value returned by the getBit method against the expected bit value.
Validation: 
The assertion aims to verify the correct bit value at the given position in the positive integer number. The correct bit value is crucial for accurate bit manipulation operations.

Scenario 2: Validating the Bit Value at a Given Position in a Negative Integer

Details:  
TestName: validateBitValueInNegativeInteger
Description: This test is meant to check the correct bit value at a given position in a negative integer number. 
Execution:
Arrange: A negative integer number and a bit position are provided.
Act: Invoke the getBit method with the negative integer number and bit position.
Assert: Use JUnit assertions to compare the actual bit value returned by the getBit method against the expected bit value.
Validation: 
The assertion aims to verify the correct bit value at the given position in the negative integer number. The correct bit value is crucial for accurate bit manipulation operations.

Scenario 3: Validating the Bit Value at Zero Position

Details:  
TestName: validateBitValueAtZeroPosition
Description: This test is meant to check the correct bit value at the zero position in a number. 
Execution:
Arrange: A number and the bit position zero are provided.
Act: Invoke the getBit method with the number and zero position.
Assert: Use JUnit assertions to compare the actual bit value returned by the getBit method against the expected bit value.
Validation: 
The assertion aims to verify the correct bit value at the zero position in the number. The correct bit value is crucial for accurate bit manipulation operations.

Scenario 4: Validating the Bit Value at the Maximum Integer Position

Details:  
TestName: validateBitValueAtMaxIntegerPosition
Description: This test is meant to check the correct bit value at the maximum integer position in a number. 
Execution:
Arrange: A number and the maximum integer position are provided.
Act: Invoke the getBit method with the number and maximum integer position.
Assert: Use JUnit assertions to compare the actual bit value returned by the getBit method against the expected bit value.
Validation: 
The assertion aims to verify the correct bit value at the maximum integer position in the number. The correct bit value is crucial for accurate bit manipulation operations.
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class SingleBitOperationsGetBitTest {
    @Test
    @Tag("valid")
    public void validateBitValueInPositiveInteger() {
        final int num = 10; // Binary: 1010
        final int bit = 3;
        final int expectedBitValue = 1;
        assertEquals(expectedBitValue, SingleBitOperations.getBit(num, bit));
    }
    @Test
    @Tag("valid")
    public void validateBitValueInNegativeInteger() {
        final int num = -10; // Binary: -1010
        final int bit = 3;
        final int expectedBitValue = 1;
        assertEquals(expectedBitValue, SingleBitOperations.getBit(num, bit));
    }
    @Test
    @Tag("boundary")
    public void validateBitValueAtZeroPosition() {
        final int num = 10; // Binary: 1010
        final int bit = 0;
        final int expectedBitValue = 0;
        assertEquals(expectedBitValue, SingleBitOperations.getBit(num, bit));
    }
    @Test
    @Tag("boundary")
    public void validateBitValueAtMaxIntegerPosition() {
        final int num = Integer.MAX_VALUE; // Binary: 1111111111111111111111111111111
        final int bit = 30;
        final int expectedBitValue = 1;
        assertEquals(expectedBitValue, SingleBitOperations.getBit(num, bit));
    }
}