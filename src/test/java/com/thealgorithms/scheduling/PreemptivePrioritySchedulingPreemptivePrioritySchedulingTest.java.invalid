// This test file is marked invalid as it contains compilation errors. Change the extension to of this file to .java, to manually edit its contents


// ********RoostGPT********
/*
Test generated by RoostGPT for test verify-test-java using AI Type  and AI Model 

ROOST_METHOD_HASH=preemptivePriorityScheduling_6d42a3f4f2
ROOST_METHOD_SIG_HASH=preemptivePriorityScheduling_cc2034b568

Based on the provided method and instructions, here are several test scenarios for the `preemptivePriorityScheduling` method:

```
Scenario 1: Basic Preemptive Priority Scheduling

Details:
  TestName: basicPreemptivePriorityScheduling
  Description: Test the basic functionality of preemptive priority scheduling with a simple set of processes.

Execution:
  Arrange: Create a list of processes with different arrival times, burst times, and priorities.
  Act: Call preemptivePriorityScheduling with the created list of processes.
  Assert: Verify that the returned Gantt chart matches the expected execution order.

Validation:
  This test ensures that the method correctly schedules processes based on their priorities and preempts lower priority processes when higher priority ones arrive. It validates the core functionality of the scheduling algorithm.

Scenario 2: Empty Process List

Details:
  TestName: emptyProcessList
  Description: Test the behavior when an empty list of processes is provided.

Execution:
  Arrange: Create an empty list of processes.
  Act: Call preemptivePriorityScheduling with the empty list.
  Assert: Verify that the returned Gantt chart is empty.

Validation:
  This test checks how the method handles edge cases, specifically when no processes are provided. It ensures that the method doesn't throw exceptions and returns an appropriate result.

Scenario 3: Single Process Scheduling

Details:
  TestName: singleProcessScheduling
  Description: Test scheduling with only one process in the list.

Execution:
  Arrange: Create a list with a single process.
  Act: Call preemptivePriorityScheduling with this list.
  Assert: Verify that the Gantt chart contains only the name of the single process, repeated for its burst time.

Validation:
  This test ensures that the method works correctly for the simplest case of scheduling, validating that it can handle a single process without issues.

Scenario 4: Processes with Same Priority

Details:
  TestName: processesWithSamePriority
  Description: Test scheduling behavior when multiple processes have the same priority.

Execution:
  Arrange: Create a list of processes where some have the same priority.
  Act: Call preemptivePriorityScheduling with this list.
  Assert: Verify that processes with the same priority are executed in the order of their arrival time.

Validation:
  This test checks how the method resolves conflicts when multiple processes have equal priority, ensuring it falls back to FCFS (First-Come, First-Served) for such cases.

Scenario 5: Idle Time Handling

Details:
  TestName: idleTimeHandling
  Description: Test how the method handles periods when no processes are ready to execute.

Execution:
  Arrange: Create a list of processes with gaps between arrival times.
  Act: Call preemptivePriorityScheduling with this list.
  Assert: Verify that "Idle" is inserted into the Gantt chart for time periods when no process is available.

Validation:
  This test ensures that the method correctly identifies and represents idle time in the scheduling, which is crucial for accurate representation of CPU utilization.

Scenario 6: Preemption of Lower Priority Process

Details:
  TestName: preemptionOfLowerPriorityProcess
  Description: Test if a running lower priority process is preempted when a higher priority process arrives.

Execution:
  Arrange: Create a list where a lower priority process arrives first, followed by a higher priority process.
  Act: Call preemptivePriorityScheduling with this list.
  Assert: Verify that the Gantt chart shows the lower priority process being preempted by the higher priority one.

Validation:
  This test is crucial for validating the preemptive nature of the scheduling algorithm, ensuring that higher priority tasks are given precedence even if it means interrupting a running lower priority task.

Scenario 7: Long-Running Process with Multiple Preemptions

Details:
  TestName: longRunningProcessWithMultiplePreemptions
  Description: Test a scenario where a long-running process is preempted multiple times by shorter, higher-priority processes.

Execution:
  Arrange: Create a list with one long-running, low-priority process and several short, high-priority processes arriving at different times.
  Act: Call preemptivePriorityScheduling with this list.
  Assert: Verify that the Gantt chart shows the long-running process being preempted multiple times and resuming after higher priority processes complete.

Validation:
  This test ensures that the scheduling algorithm can handle complex scenarios with multiple preemptions, validating its ability to manage realistic workloads with varying priorities and execution times.
```

These scenarios cover a range of cases from basic functionality to edge cases and complex scheduling situations, providing a comprehensive test suite for the `preemptivePriorityScheduling` method.
*/

// ********RoostGPT********
package com.thealgorithms.scheduling;import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.*;
import java.util.Comparator;
import java.util.PriorityQueue;

class PreemptivePrioritySchedulingPreemptivePrioritySchedulingTest {
    @Test
    @Tag("valid")
    void basicPreemptivePriorityScheduling() {
        List<Process> processes = new ArrayList<>();
        processes.add(new Process("P1", 0, 10, 2));
        processes.add(new Process("P2", 1, 5, 1));
        processes.add(new Process("P3", 3, 2, 3));
        List<String> expectedGanttChart = List.of("P1", "P1", "P3", "P3", "P1", "P1", "P1", "P1", "P1", "P1", "P1", "P1", "P2", "P2", "P2", "P2", "P2");
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertEquals(expectedGanttChart, actualGanttChart);
    }
    @Test
    @Tag("boundary")
    void emptyProcessList() {
        List<Process> processes = new ArrayList<>();
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertTrue(actualGanttChart.isEmpty());
    }
    @Test
    @Tag("valid")
    void singleProcessScheduling() {
        List<Process> processes = new ArrayList<>();
        processes.add(new Process("P1", 0, 5, 1));
        List<String> expectedGanttChart = List.of("P1", "P1", "P1", "P1", "P1");
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertEquals(expectedGanttChart, actualGanttChart);
    }
    @Test
    @Tag("valid")
    void processesWithSamePriority() {
        List<Process> processes = new ArrayList<>();
        processes.add(new Process("P1", 0, 3, 2));
        processes.add(new Process("P2", 1, 3, 2));
        processes.add(new Process("P3", 2, 3, 2));
        List<String> expectedGanttChart = List.of("P1", "P1", "P1", "P2", "P2", "P2", "P3", "P3", "P3");
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertEquals(expectedGanttChart, actualGanttChart);
    }
    @Test
    @Tag("valid")
    void idleTimeHandling() {
        List<Process> processes = new ArrayList<>();
        processes.add(new Process("P1", 0, 2, 1));
        processes.add(new Process("P2", 3, 2, 2));
        List<String> expectedGanttChart = List.of("P1", "P1", "Idle", "P2", "P2");
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertEquals(expectedGanttChart, actualGanttChart);
    }
    @Test
    @Tag("valid")
    void preemptionOfLowerPriorityProcess() {
        List<Process> processes = new ArrayList<>();
        processes.add(new Process("P1", 0, 4, 1));
        processes.add(new Process("P2", 1, 2, 2));
        List<String> expectedGanttChart = List.of("P1", "P2", "P2", "P1", "P1", "P1");
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertEquals(expectedGanttChart, actualGanttChart);
    }
    @Test
    @Tag("valid")
    void longRunningProcessWithMultiplePreemptions() {
        List<Process> processes = new ArrayList<>();
        processes.add(new Process("P1", 0, 10, 1));
        processes.add(new Process("P2", 1, 2, 3));
        processes.add(new Process("P3", 3, 1, 4));
        processes.add(new Process("P4", 5, 2, 2));
        List<String> expectedGanttChart = List.of("P1", "P2", "P2", "P3", "P1", "P4", "P4", "P1", "P1", "P1", "P1", "P1", "P1", "P1");
        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);
        assertEquals(expectedGanttChart, actualGanttChart);
    }
    private static class Process {
        String name;
        int arrivalTime;
        int burstTime;
        int priority;
        Process(String name, int arrivalTime, int burstTime, int priority) {
            this.name = name;
            this.arrivalTime = arrivalTime;
            this.burstTime = burstTime;
            this.priority = priority;
        }
    }
}