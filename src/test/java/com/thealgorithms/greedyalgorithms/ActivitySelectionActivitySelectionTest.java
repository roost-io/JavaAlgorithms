// ********RoostGPT********
/*
Test generated by RoostGPT for test java-algos using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620
ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f
Based on the provided method and imports, here are several test scenarios for the `activitySelection` method:
```
Scenario 1: Basic Activity Selection
Details:
  TestName: basicActivitySelection
  Description: Test the basic functionality of activity selection with a simple set of non-overlapping activities.
Execution:
  Arrange: Create arrays for start times and end times with non-overlapping activities.
  Act: Call activitySelection with the arranged start and end times.
  Assert: Verify that all activities are selected in the correct order.
Validation:
  This test ensures that the method correctly selects all activities when there are no conflicts. It validates the core functionality of the activity selection algorithm.
Scenario 2: Overlapping Activities
Details:
  TestName: overlappingActivities
  Description: Test the method's ability to select the maximum number of non-overlapping activities from a set of overlapping activities.
Execution:
  Arrange: Create arrays for start times and end times with some overlapping activities.
  Act: Call activitySelection with the arranged start and end times.
  Assert: Verify that the correct subset of non-overlapping activities is selected.
Validation:
  This test checks if the method correctly handles overlapping activities and selects the optimal set of non-overlapping activities. It validates the core logic of the greedy algorithm.
Scenario 3: Empty Input Arrays
Details:
  TestName: emptyInputArrays
  Description: Test the method's behavior when given empty input arrays.
Execution:
  Arrange: Create empty arrays for start times and end times.
  Act: Call activitySelection with the empty arrays.
  Assert: Verify that an empty ArrayList is returned.
Validation:
  This test ensures that the method handles edge cases correctly, specifically when no activities are provided. It's important for robustness and error handling.
Scenario 4: Single Activity
Details:
  TestName: singleActivity
  Description: Test the method's behavior with only one activity.
Execution:
  Arrange: Create arrays for start times and end times with a single activity.
  Act: Call activitySelection with the single-activity arrays.
  Assert: Verify that the returned ArrayList contains only the index of the single activity.
Validation:
  This test checks if the method correctly handles the simplest non-empty case. It's important for ensuring basic functionality and edge case handling.
Scenario 5: Activities with Same End Time
Details:
  TestName: activitiesWithSameEndTime
  Description: Test the method's behavior when multiple activities have the same end time.
Execution:
  Arrange: Create arrays for start times and end times where multiple activities end at the same time.
  Act: Call activitySelection with these arrays.
  Assert: Verify that the method selects the correct activities based on their start times.
Validation:
  This test ensures that the method can handle ties in end times correctly, which is important for the stability and consistency of the algorithm.
Scenario 6: Activities with Same Start Time
Details:
  TestName: activitiesWithSameStartTime
  Description: Test the method's behavior when multiple activities have the same start time.
Execution:
  Arrange: Create arrays for start times and end times where multiple activities start at the same time.
  Act: Call activitySelection with these arrays.
  Assert: Verify that the method selects the activities with the earliest end times.
Validation:
  This test checks if the method correctly prioritizes activities with earlier end times when start times are the same, which is crucial for the greedy algorithm's correctness.
Scenario 7: Large Number of Activities
Details:
  TestName: largeNumberOfActivities
  Description: Test the method's performance and correctness with a large number of activities.
Execution:
  Arrange: Create large arrays for start times and end times with many activities.
  Act: Call activitySelection with these large arrays.
  Assert: Verify that the method returns a correct selection of activities within a reasonable time.
Validation:
  This test ensures that the method can handle large inputs efficiently, which is important for scalability. It also checks if the algorithm maintains correctness with complex inputs.
```
These test scenarios cover various aspects of the `activitySelection` method, including basic functionality, edge cases, and potential challenging scenarios. They aim to validate the correctness, robustness, and efficiency of the implementation.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Stream;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.datastructures.bags")
@Tag("com.thealgorithms.datastructures.bags.add")
@Tag("com.thealgorithms.datastructures.bags.add")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.activitySelection")
class ActivitySelectionActivitySelectionTest {

	@Test
	void basicActivitySelection() {
		int[] startTimes = { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = { 2, 4, 6, 7, 9, 9 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 3, 4));
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@Test
	void overlappingActivities() {
		int[] startTimes = { 1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12 };
		int[] endTimes = { 4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 3, 7, 10));
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@Test
	void emptyInputArrays() {
		int[] startTimes = {};
		int[] endTimes = {};
		ArrayList<Integer> expected = new ArrayList<>();
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@Test
	void singleActivity() {
		int[] startTimes = { 1 };
		int[] endTimes = { 2 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@Test
	void activitiesWithSameEndTime() {
		int[] startTimes = { 1, 3, 2, 5 };
		int[] endTimes = { 4, 4, 4, 6 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 3));
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@Test
	void activitiesWithSameStartTime() {
		int[] startTimes = { 1, 1, 1, 4 };
		int[] endTimes = { 2, 3, 4, 5 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 3));
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@Test
	void largeNumberOfActivities() {
		int[] startTimes = new int[1000];
		int[] endTimes = new int[1000];
		for (int i = 0; i < 1000; i++) {
			startTimes[i] = i * 2;
			endTimes[i] = i * 2 + 1;
		}
		ArrayList<Integer> expected = new ArrayList<>();
		for (int i = 0; i < 1000; i++) {
			expected.add(i);
		}
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	@ParameterizedTest
	@MethodSource("provideActivitySelectionTestCases")
	void parameterizedActivitySelectionTest(int[] startTimes, int[] endTimes, ArrayList<Integer> expected) {
		assertThat(ActivitySelection.activitySelection(startTimes, endTimes)).isEqualTo(expected);
	}

	private static Stream<Arguments> provideActivitySelectionTestCases() {
		return Stream.of(
				Arguments.of(new int[] { 1, 3, 0, 5, 8, 5 }, new int[] { 2, 4, 6, 7, 9, 9 },
						new ArrayList<>(Arrays.asList(0, 1, 3, 4))),
				Arguments.of(new int[] { 1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12 },
						new int[] { 4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16 },
						new ArrayList<>(Arrays.asList(0, 3, 7, 10))),
				Arguments.of(new int[] {}, new int[] {}, new ArrayList<>()),
				Arguments.of(new int[] { 1 }, new int[] { 2 }, new ArrayList<>(Arrays.asList(0))),
				Arguments.of(new int[] { 1, 3, 2, 5 }, new int[] { 4, 4, 4, 6 }, new ArrayList<>(Arrays.asList(0, 3))),
				Arguments.of(new int[] { 1, 1, 1, 4 }, new int[] { 2, 3, 4, 5 }, new ArrayList<>(Arrays.asList(0, 3))));
	}

}