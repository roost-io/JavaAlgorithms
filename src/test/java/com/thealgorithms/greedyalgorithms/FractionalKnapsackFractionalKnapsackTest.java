// ********RoostGPT********
/*
Test generated by RoostGPT for test java-algos using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620
ROOST_METHOD_HASH=fractionalKnapsack_b327dd7d5e
ROOST_METHOD_SIG_HASH=fractionalKnapsack_1caf503527
Based on the provided method and instructions, here are several test scenarios for the fractionalKnapsack method:
Scenario 1: Basic Functionality Test
Details:
  TestName: basicFunctionalityTest
  Description: Verify that the method correctly calculates the maximum value for a simple knapsack problem with distinct items.
Execution:
  Arrange: Create weight array, value array, and set capacity.
  Act: Call fractionalKnapsack with the arranged data.
  Assert: Compare the returned value with the expected maximum value.
Validation:
  This test ensures that the basic algorithm works correctly for a straightforward case. It validates that the method can properly sort items by value-to-weight ratio and select the most valuable items within the given capacity.
Scenario 2: Full Capacity Utilization
Details:
  TestName: fullCapacityUtilization
  Description: Test the method's ability to utilize the full capacity of the knapsack when possible.
Execution:
  Arrange: Set up weight and value arrays where the sum of weights exactly matches the capacity.
  Act: Invoke fractionalKnapsack with the arranged data.
  Assert: Verify that the returned value is the sum of all item values.
Validation:
  This test confirms that the method can efficiently use the entire knapsack capacity when the items fit perfectly, ensuring no space is wasted.
Scenario 3: Fractional Item Inclusion
Details:
  TestName: fractionalItemInclusion
  Description: Verify that the method correctly includes a fraction of an item when the knapsack is almost full.
Execution:
  Arrange: Create arrays where the last item needs to be fractionally included.
  Act: Call fractionalKnapsack with the arranged data.
  Assert: Check if the returned value includes the correct fraction of the last item.
Validation:
  This test ensures that the method can handle fractional items correctly, which is a key aspect of the fractional knapsack problem.
Scenario 4: Empty Knapsack
Details:
  TestName: emptyKnapsack
  Description: Test the method's behavior when the knapsack capacity is zero.
Execution:
  Arrange: Set up non-empty weight and value arrays but set capacity to 0.
  Act: Invoke fractionalKnapsack with zero capacity.
  Assert: Verify that the returned value is 0.
Validation:
  This test checks the edge case of a zero-capacity knapsack, ensuring the method handles it gracefully without errors.
Scenario 5: Single Item Knapsack
Details:
  TestName: singleItemKnapsack
  Description: Verify the method's functionality when there's only one item to consider.
Execution:
  Arrange: Create weight and value arrays with a single element.
  Act: Call fractionalKnapsack with the single-item data.
  Assert: Check if the returned value is correct for the single item case.
Validation:
  This test ensures that the method works correctly in the simplest case scenario, handling array inputs with just one element.
Scenario 6: Large Number of Items
Details:
  TestName: largeNumberOfItems
  Description: Test the method's performance and correctness with a large number of items.
Execution:
  Arrange: Create large weight and value arrays (e.g., 1000+ items).
  Act: Invoke fractionalKnapsack with the large dataset.
  Assert: Verify that the returned value is correct and the method executes within an acceptable time frame.
Validation:
  This test checks the method's efficiency and correctness when dealing with a large dataset, ensuring it can handle real-world scenarios with many items.
Scenario 7: All Items with Same Value-to-Weight Ratio
Details:
  TestName: sameValueWeightRatio
  Description: Verify the method's behavior when all items have the same value-to-weight ratio.
Execution:
  Arrange: Set up weight and value arrays where all items have identical value-to-weight ratios.
  Act: Call fractionalKnapsack with the arranged data.
  Assert: Check if the returned value is correct regardless of which items are chosen.
Validation:
  This test ensures that the method handles the special case where the sorting of items doesn't affect the final result, as all items are equally valuable relative to their weight.
These test scenarios cover various aspects of the fractionalKnapsack method, including basic functionality, edge cases, and special situations. They aim to thoroughly validate the method's correctness and robustness.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import static org.junit.jupiter.api.Assertions.*;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.stream.Stream;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.fractionalKnapsack")
class FractionalKnapsackFractionalKnapsackTest {

	@Test
	void basicFunctionalityTest() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = 50;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(240, result);
	}

	@Test
	void fullCapacityUtilization() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = 60;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(280, result);
	}

	@Test
	void fractionalItemInclusion() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = 55;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(260, result);
	}

	@Test
	void emptyKnapsack() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = 0;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(0, result);
	}

	@Test
	void singleItemKnapsack() {
		int[] weight = { 50 };
		int[] value = { 100 };
		int capacity = 30;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(60, result);
	}

	@Test
	void largeNumberOfItems() {
		int[] weight = new int[1000];
		int[] value = new int[1000];
		for (int i = 0; i < 1000; i++) {
			weight[i] = i + 1;
			value[i] = (i + 1) * 10;
		}
		int capacity = 5000;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertTrue(result > 0);
	}

	@Test
	void sameValueWeightRatio() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 20, 40, 60 };
		int capacity = 40;
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(80, result);
	}

	@ParameterizedTest
	@MethodSource("provideTestCases")
	void parameterizedTest(int[] weight, int[] value, int capacity, int expected) {
		int result = FractionalKnapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(expected, result);
	}

	private static Stream<Arguments> provideTestCases() {
		return Stream.of(Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 50, 240),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 60, 280),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 55, 260),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 0, 0),
				Arguments.of(new int[] { 50 }, new int[] { 100 }, 30, 60),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 20, 40, 60 }, 40, 80));
	}

}