// ********RoostGPT********
/*
Test generated by RoostGPT for test java-algos using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620
ROOST_METHOD_HASH=fractionalKnapsack_b327dd7d5e
ROOST_METHOD_SIG_HASH=fractionalKnapsack_1caf503527
================================VULNERABILITIES================================
Vulnerability: integer overflow
Issue: The calculation of finalValue += (int) (ratio[i][1] * current) may lead to integer overflow if the result exceeds Integer.MAX_VALUE.
Solution: Use long for finalValue and cast the result to int only when returning. Also, consider using BigInteger for very large values.
Vulnerability: floating-point precision loss
Issue: Using double for ratio calculations can lead to precision loss, potentially affecting the accuracy of the knapsack algorithm.
Solution: Consider using BigDecimal for precise decimal calculations, especially when dealing with currency or other sensitive numerical data.
Vulnerability: array index out of bounds
Issue: If the weight or value arrays are empty, accessing ratio[i][0] or ratio[i][1] could cause an ArrayIndexOutOfBoundsException.
Solution: Add input validation to check if weight and value arrays are non-empty before processing.
Vulnerability: null pointer dereference
Issue: The method doesn't check if the input arrays (weight and value) are null, which could lead to a NullPointerException.
Solution: Add null checks for input parameters at the beginning of the method and throw an IllegalArgumentException if they are null.
Vulnerability: input validation
Issue: The method doesn't validate if the capacity is non-negative or if the weight and value arrays have the same length.
Solution: Add input validation to ensure capacity is non-negative and that weight and value arrays have the same length. Throw IllegalArgumentException for invalid inputs.
================================================================================
Based on the provided method and instructions, here are several test scenarios for the fractionalKnapsack method:
Scenario 1: Basic Functionality Test
Details:
  TestName: basicFunctionalityTest
  Description: Verify that the method correctly calculates the maximum value for a simple knapsack problem with integer weights and values.
Execution:
  Arrange: Create arrays for weights, values, and set a capacity.
  Act: Call fractionalKnapsack with the prepared data.
  Assert: Compare the returned value with the expected maximum value.
Validation:
  This test ensures that the basic algorithm works correctly for a straightforward case. It validates that the method can properly sort items by value-to-weight ratio and select the most valuable items within the given capacity.
Scenario 2: Fractional Item Test
Details:
  TestName: fractionalItemTest
  Description: Test the method's ability to handle fractional items when the knapsack can't fit a whole item.
Execution:
  Arrange: Set up weight and value arrays where the last item to be added would exceed the capacity.
  Act: Invoke fractionalKnapsack with the prepared data.
  Assert: Verify that the returned value includes a fraction of the last item.
Validation:
  This test checks if the method correctly calculates and adds the value of a fractional item when the knapsack is almost full. It's crucial for verifying the "fractional" aspect of the algorithm.
Scenario 3: Empty Knapsack Test
Details:
  TestName: emptyKnapsackTest
  Description: Verify the method's behavior when the knapsack capacity is zero.
Execution:
  Arrange: Prepare non-empty weight and value arrays, but set the capacity to 0.
  Act: Call fractionalKnapsack with zero capacity.
  Assert: Confirm that the returned value is 0.
Validation:
  This test ensures that the method handles the edge case of zero capacity correctly, returning no value as expected.
Scenario 4: Single Item Test
Details:
  TestName: singleItemTest
  Description: Test the method with only one item in the knapsack.
Execution:
  Arrange: Create weight and value arrays with a single element.
  Act: Invoke fractionalKnapsack with the single-item data.
  Assert: Check if the returned value matches the expected value for the single item.
Validation:
  This test verifies that the method works correctly with the minimal input of just one item, ensuring no errors occur in edge cases with minimal data.
Scenario 5: Capacity Exceeds Total Weight Test
Details:
  TestName: capacityExceedsTotalWeightTest
  Description: Test the scenario where the knapsack capacity is larger than the total weight of all items.
Execution:
  Arrange: Set up weight and value arrays where the sum of weights is less than the capacity.
  Act: Call fractionalKnapsack with the prepared data.
  Assert: Verify that the returned value is the sum of all item values.
Validation:
  This test ensures that when the capacity is more than sufficient, the method correctly includes all items and returns their total value.
Scenario 6: Large Number of Items Test
Details:
  TestName: largeNumberOfItemsTest
  Description: Verify the method's performance and correctness with a large number of items.
Execution:
  Arrange: Create large arrays for weights and values (e.g., 10000 items).
  Act: Invoke fractionalKnapsack with the large dataset.
  Assert: Compare the returned value with a pre-calculated expected value.
Validation:
  This test checks the method's ability to handle large inputs efficiently and correctly, which is important for real-world scenarios with many items.
Scenario 7: All Items with Same Ratio Test
Details:
  TestName: allItemsSameRatioTest
  Description: Test the method's behavior when all items have the same value-to-weight ratio.
Execution:
  Arrange: Prepare weight and value arrays where all items have the same value-to-weight ratio.
  Act: Call fractionalKnapsack with the prepared data.
  Assert: Verify that the returned value matches the expected maximum value.
Validation:
  This test ensures that the method works correctly when the sorting step doesn't differentiate between items, checking if it properly fills the knapsack in this edge case.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import static org.junit.jupiter.api.Assertions.*;
import java.util.stream.Stream;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.fractionalKnapsack")
class FractionalKnapsackFractionalKnapsackTest {

	@Test
	void basicFunctionalityTest() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 50;
		int expectedValue = 240;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void fractionalItemTest() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 55;
		int expectedValue = 250;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void emptyKnapsackTest() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 0;
		int expectedValue = 0;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void singleItemTest() {
		int[] weights = { 50 };
		int[] values = { 100 };
		int capacity = 50;
		int expectedValue = 100;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void capacityExceedsTotalWeightTest() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 100;
		int expectedValue = 280;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void largeNumberOfItemsTest() {
		int[] weights = new int[10000];
		int[] values = new int[10000];
		for (int i = 0; i < 10000; i++) {
			weights[i] = i + 1;
			values[i] = (i + 1) * 10;
		}
		int capacity = 5000;
		int expectedValue = 495050;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void allItemsSameRatioTest() {
		int[] weights = { 10, 20, 30, 40, 50 };
		int[] values = { 20, 40, 60, 80, 100 };
		int capacity = 100;
		int expectedValue = 200;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@ParameterizedTest
	@MethodSource("provideTestCases")
	void parameterizedTest(int[] weights, int[] values, int capacity, int expectedValue) {
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	private static Stream<Arguments> provideTestCases() {
		return Stream.of(Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 50, 240),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 55, 250),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 0, 0),
				Arguments.of(new int[] { 50 }, new int[] { 100 }, 50, 100),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 100, 280),
				Arguments.of(new int[] { 10, 20, 30, 40, 50 }, new int[] { 20, 40, 60, 80, 100 }, 100, 200));
	}

}