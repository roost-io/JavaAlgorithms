// ********RoostGPT********
/*
Test generated by RoostGPT for test java-algos using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620
ROOST_METHOD_HASH=fractionalKnapsack_b327dd7d5e
ROOST_METHOD_SIG_HASH=fractionalKnapsack_1caf503527
================================VULNERABILITIES================================
Vulnerability: integer overflow
Issue: The calculation of finalValue += (int) (ratio[i][1] * current) may lead to integer overflow if the result exceeds Integer.MAX_VALUE.
Solution: Use long or BigInteger for finalValue to handle larger values, or implement overflow checks before addition.
Vulnerability: floating-point precision
Issue: Using double for ratio calculations may lead to precision errors, potentially affecting the accuracy of the knapsack algorithm.
Solution: Consider using BigDecimal for precise decimal arithmetic, especially when dealing with financial calculations or when high precision is required.
Vulnerability: array index out of bounds
Issue: If the input arrays weight and value have different lengths, it may cause ArrayIndexOutOfBoundsException.
Solution: Add a check at the beginning of the method to ensure that weight.length == value.length, throwing an IllegalArgumentException if they don't match.
Vulnerability: null pointer dereference
Issue: The method doesn't check if the input arrays weight and value are null, which could lead to NullPointerException.
Solution: Add null checks for input parameters at the beginning of the method, throwing NullPointerException with appropriate error messages if null is detected.
Vulnerability: integer division
Issue: The calculation ratio[i][1] = value[i] / (double) weight[i] may result in division by zero if weight[i] is 0.
Solution: Add a check to ensure weight[i] is not zero before performing the division. Handle zero weights appropriately, either by skipping the item or assigning a special value.
================================================================================
Based on the provided method and instructions, here are several test scenarios for the fractionalKnapsack method:
Scenario 1: Basic Functionality Test
Details:
  TestName: basicFunctionalityTest
  Description: Verify that the method correctly calculates the maximum value for a simple knapsack problem.
Execution:
  Arrange: Create arrays for weights, values, and set a capacity.
  Act: Call fractionalKnapsack with the prepared data.
  Assert: Compare the returned value with the expected maximum value.
Validation:
  This test ensures that the basic algorithm works correctly for a straightforward case. It's crucial to verify that the method can handle a simple scenario before testing more complex cases.
Scenario 2: Full Capacity Utilization
Details:
  TestName: fullCapacityUtilization
  Description: Test when the knapsack can be filled to its exact capacity with whole items.
Execution:
  Arrange: Set up weight and value arrays where items can perfectly fill the knapsack.
  Act: Invoke fractionalKnapsack with these arrays and the exact capacity.
  Assert: Check if the returned value matches the sum of all item values.
Validation:
  This test verifies that the method correctly handles cases where no fractional items are needed, utilizing the full capacity efficiently.
Scenario 3: Fractional Item Inclusion
Details:
  TestName: fractionalItemInclusion
  Description: Verify that the method correctly includes a fraction of an item to maximize value.
Execution:
  Arrange: Create arrays where the last item needs to be fractionally included.
  Act: Call fractionalKnapsack with these arrays and a capacity that requires fractional inclusion.
  Assert: Confirm that the returned value includes the correct fractional value of the last item.
Validation:
  This test is critical to ensure that the fractional aspect of the algorithm works correctly, which is a key feature of the fractional knapsack problem.
Scenario 4: Empty Input Arrays
Details:
  TestName: emptyInputArrays
  Description: Test the method's behavior when given empty weight and value arrays.
Execution:
  Arrange: Create empty weight and value arrays.
  Act: Call fractionalKnapsack with empty arrays and a positive capacity.
  Assert: Verify that the method returns 0 or handles empty inputs appropriately.
Validation:
  This test checks the method's robustness in handling edge cases, specifically when no items are available.
Scenario 5: Zero Capacity Knapsack
Details:
  TestName: zeroCapacityKnapsack
  Description: Verify the method's response when the knapsack capacity is zero.
Execution:
  Arrange: Set up normal weight and value arrays.
  Act: Invoke fractionalKnapsack with these arrays but set capacity to 0.
  Assert: Confirm that the method returns 0 as no items can be included.
Validation:
  This test ensures that the method correctly handles the edge case of a knapsack with no capacity, preventing any erroneous calculations.
Scenario 6: Single Item Larger Than Capacity
Details:
  TestName: singleItemLargerThanCapacity
  Description: Test when there's only one item and its weight exceeds the knapsack capacity.
Execution:
  Arrange: Create arrays with a single item whose weight is greater than the capacity.
  Act: Call fractionalKnapsack with these single-item arrays and a smaller capacity.
  Assert: Check if the returned value is the correct fraction of the item's value.
Validation:
  This test verifies that the method correctly calculates fractional value when the entire item cannot fit, which is crucial for the fractional knapsack algorithm.
Scenario 7: Items with Zero Weight
Details:
  TestName: itemsWithZeroWeight
  Description: Verify how the method handles items with zero weight.
Execution:
  Arrange: Set up arrays including items with zero weight but positive value.
  Act: Invoke fractionalKnapsack with these arrays and a positive capacity.
  Assert: Confirm that zero-weight items are correctly handled and included in the final value.
Validation:
  This test checks the method's ability to handle potential division by zero and ensures that valuable items with no weight are correctly included.
These scenarios cover various aspects of the fractionalKnapsack method, including basic functionality, edge cases, and potential error conditions. They aim to thoroughly test the method's correctness and robustness.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import static org.junit.jupiter.api.Assertions.*;
import java.util.stream.Stream;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.fractionalKnapsack")
class FractionalKnapsackFractionalKnapsackTest {

	@Test
	void basicFunctionalityTest() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 50;
		int expectedValue = 240;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void fullCapacityUtilization() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 60;
		int expectedValue = 280;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void fractionalItemInclusion() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 55;
		int expectedValue = 260;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void emptyInputArrays() {
		int[] weights = {};
		int[] values = {};
		int capacity = 50;
		int expectedValue = 0;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void zeroCapacityKnapsack() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 0;
		int expectedValue = 0;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void singleItemLargerThanCapacity() {
		int[] weights = { 100 };
		int[] values = { 500 };
		int capacity = 50;
		int expectedValue = 250;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@Test
	void itemsWithZeroWeight() {
		int[] weights = { 0, 20, 30 };
		int[] values = { 50, 100, 120 };
		int capacity = 50;
		int expectedValue = 270;
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	@ParameterizedTest
	@MethodSource("provideTestCases")
	void parameterizedTest(int[] weights, int[] values, int capacity, int expectedValue) {
		assertEquals(expectedValue, FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

	private static Stream<Arguments> provideTestCases() {
		return Stream.of(Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 50, 240),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 60, 280),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 55, 260),
				Arguments.of(new int[] {}, new int[] {}, 50, 0),
				Arguments.of(new int[] { 10, 20, 30 }, new int[] { 60, 100, 120 }, 0, 0),
				Arguments.of(new int[] { 100 }, new int[] { 500 }, 50, 250),
				Arguments.of(new int[] { 0, 20, 30 }, new int[] { 50, 100, 120 }, 50, 270));
	}

}