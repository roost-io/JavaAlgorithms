
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=keyExpansion_55cd901b8f
ROOST_METHOD_SIG_HASH=keyExpansion_cdf6f28d3c

Based on the provided method `keyExpansion` and the associated class information, here are several test scenarios for the `keyExpansion` method:

```
Scenario 1: Key Expansion with Valid Initial Key

Details:
  TestName: keyExpansionWithValidInitialKey
  Description: Test the key expansion process with a valid 128-bit initial key to ensure it generates the correct number of round keys.

Execution:
  Arrange: Create a BigInteger representing a valid 128-bit initial key.
  Act: Call the keyExpansion method with the initial key.
  Assert: Verify that the returned array has 11 elements (10 round keys + initial key).

Validation:
  This test ensures that the keyExpansion method correctly generates the expected number of round keys for the AES algorithm. It's crucial for the proper functioning of the encryption and decryption processes.

Scenario 2: First Round Key Matches Initial Key

Details:
  TestName: firstRoundKeyMatchesInitialKey
  Description: Verify that the first element in the returned array of round keys matches the provided initial key.

Execution:
  Arrange: Create a BigInteger representing a valid 128-bit initial key.
  Act: Call the keyExpansion method with the initial key.
  Assert: Check that the first element of the returned array equals the initial key.

Validation:
  This test confirms that the keyExpansion method correctly sets the first round key to be the initial key, which is a fundamental requirement of the AES key schedule.

Scenario 3: Subsequent Round Keys Are Different

Details:
  TestName: subsequentRoundKeysAreDifferent
  Description: Ensure that each subsequent round key is different from the previous one.

Execution:
  Arrange: Create a BigInteger representing a valid 128-bit initial key.
  Act: Call the keyExpansion method with the initial key.
  Assert: Iterate through the returned array and verify that each key is different from its predecessor.

Validation:
  This test checks that the key expansion algorithm is generating unique keys for each round, which is essential for the security of the AES encryption process.

Scenario 4: Key Expansion with Zero Initial Key

Details:
  TestName: keyExpansionWithZeroInitialKey
  Description: Test the key expansion process with an initial key of zero to ensure it handles this edge case correctly.

Execution:
  Arrange: Create a BigInteger representing a 128-bit key of all zeros.
  Act: Call the keyExpansion method with the zero key.
  Assert: Verify that the method returns an array of 11 elements and that they are not all zero.

Validation:
  This test ensures that the keyExpansion method can handle the edge case of a zero initial key without failing or producing an invalid key schedule.

Scenario 5: Key Expansion Consistency

Details:
  TestName: keyExpansionConsistency
  Description: Verify that multiple calls to keyExpansion with the same initial key produce identical results.

Execution:
  Arrange: Create a BigInteger representing a valid 128-bit initial key.
  Act: Call the keyExpansion method twice with the same initial key.
  Assert: Compare the two returned arrays to ensure they are identical.

Validation:
  This test confirms the deterministic nature of the key expansion algorithm, which is crucial for consistent encryption and decryption operations.

Scenario 6: Key Expansion with Maximum Value Initial Key

Details:
  TestName: keyExpansionWithMaxValueInitialKey
  Description: Test the key expansion process with the maximum possible 128-bit value as the initial key.

Execution:
  Arrange: Create a BigInteger representing the maximum 128-bit value (all bits set to 1).
  Act: Call the keyExpansion method with this maximum value key.
  Assert: Verify that the method returns an array of 11 elements without throwing any exceptions.

Validation:
  This test ensures that the keyExpansion method can handle the edge case of the maximum possible key value without overflowing or producing invalid results.
```

These test scenarios cover various aspects of the `keyExpansion` method, including normal operation, edge cases, and consistency checks. They aim to ensure the correct functionality of the key expansion process, which is crucial for the overall security and proper operation of the AES encryption algorithm.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import java.math.BigInteger;
import java.util.Scanner;

class AesKeyExpansionTest {

	@Test
	@Tag("valid")
	void keyExpansionWithValidInitialKey() {
		BigInteger initialKey = new BigInteger("2b7e151628aed2a6abf7158809cf4f3c", 16);
		BigInteger[] roundKeys = AES.keyExpansion(initialKey);
		assertEquals(11, roundKeys.length);
	}

	@Test
	@Tag("valid")
	void firstRoundKeyMatchesInitialKey() {
		BigInteger initialKey = new BigInteger("2b7e151628aed2a6abf7158809cf4f3c", 16);
		BigInteger[] roundKeys = AES.keyExpansion(initialKey);
		assertEquals(initialKey, roundKeys[0]);
	}

	@Test
	@Tag("valid")
	void subsequentRoundKeysAreDifferent() {
		BigInteger initialKey = new BigInteger("2b7e151628aed2a6abf7158809cf4f3c", 16);
		BigInteger[] roundKeys = AES.keyExpansion(initialKey);
		for (int i = 1; i < roundKeys.length; i++) {
			assertNotEquals(roundKeys[i - 1], roundKeys[i]);
		}
	}

	@Test
	@Tag("boundary")
	void keyExpansionWithZeroInitialKey() {
		BigInteger initialKey = BigInteger.ZERO;
		BigInteger[] roundKeys = AES.keyExpansion(initialKey);
		assertEquals(11, roundKeys.length);
		assertFalse(allZero(roundKeys));
	}

	@Test
	@Tag("valid")
	void keyExpansionConsistency() {
		BigInteger initialKey = new BigInteger("000102030405060708090a0b0c0d0e0f", 16);
		BigInteger[] roundKeys1 = AES.keyExpansion(initialKey);
		BigInteger[] roundKeys2 = AES.keyExpansion(initialKey);
		assertArrayEquals(roundKeys1, roundKeys2);
	}

	@Test
	@Tag("boundary")
	void keyExpansionWithMaxValueInitialKey() {
		BigInteger initialKey = new BigInteger("ffffffffffffffffffffffffffffffff", 16);
		BigInteger[] roundKeys = AES.keyExpansion(initialKey);
		assertEquals(11, roundKeys.length);
	}

	private boolean allZero(BigInteger[] array) {
		for (BigInteger bi : array) {
			if (!bi.equals(BigInteger.ZERO)) {
				return false;
			}
		}
		return true;
	}

}