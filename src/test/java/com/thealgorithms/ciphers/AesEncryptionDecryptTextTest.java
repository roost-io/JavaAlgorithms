
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=decryptText_9d00d2bb37
ROOST_METHOD_SIG_HASH=decryptText_5a701f60bf

Based on the provided information, here are several test scenarios for the `decryptText` method in the `AESEncryption` class:

Scenario 1: Successful Decryption of Valid Encrypted Text

Details:
  TestName: decryptValidEncryptedText
  Description: Verify that the method can successfully decrypt a valid encrypted text using the correct secret key.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Create a plain text string
    - Encrypt the plain text using encryptText()
  Act:
    - Call decryptText() with the encrypted text and the secret key
  Assert:
    - Check if the decrypted text matches the original plain text

Validation:
  This test ensures that the decryption process works correctly for a valid input. It validates the core functionality of the AES decryption algorithm implementation.

Scenario 2: Decryption with Incorrect Secret Key

Details:
  TestName: decryptWithIncorrectKey
  Description: Attempt to decrypt an encrypted text using an incorrect secret key.

Execution:
  Arrange:
    - Generate two different secret keys using getSecretEncryptionKey()
    - Create a plain text string
    - Encrypt the plain text using one key
  Act:
    - Call decryptText() with the encrypted text and the other (incorrect) key
  Assert:
    - Expect an exception to be thrown (likely BadPaddingException or IllegalBlockSizeException)

Validation:
  This test verifies that the decryption fails when an incorrect key is used, which is crucial for the security of the encryption system.

Scenario 3: Decryption of Empty Byte Array

Details:
  TestName: decryptEmptyByteArray
  Description: Attempt to decrypt an empty byte array to test edge case handling.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Create an empty byte array
  Act:
    - Call decryptText() with the empty byte array and the secret key
  Assert:
    - Expect an exception to be thrown or an empty string to be returned (depending on implementation)

Validation:
  This test checks how the method handles an edge case of an empty input, ensuring robustness in error handling.

Scenario 4: Decryption with Null Secret Key

Details:
  TestName: decryptWithNullKey
  Description: Attempt to decrypt a valid encrypted text using a null secret key.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Create and encrypt a plain text
  Act:
    - Call decryptText() with the encrypted text and a null secret key
  Assert:
    - Expect an InvalidKeyException to be thrown

Validation:
  This test ensures that the method properly handles invalid input in the form of a null key, which is important for preventing null pointer exceptions and maintaining security.

Scenario 5: Decryption of Altered Ciphertext

Details:
  TestName: decryptAlteredCiphertext
  Description: Attempt to decrypt a ciphertext that has been altered after encryption.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Create and encrypt a plain text
    - Alter one byte in the encrypted text
  Act:
    - Call decryptText() with the altered encrypted text and the correct key
  Assert:
    - Expect an AEADBadTagException or similar integrity-related exception

Validation:
  This test verifies the integrity check feature of AES-GCM, ensuring that any tampering with the ciphertext is detected during decryption.

These scenarios cover various aspects of the decryptText method, including normal operation, error handling, and edge cases. They test the method's ability to correctly decrypt valid input, handle invalid inputs, and maintain the security properties of the AES-GCM encryption scheme.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.spec.GCMParameterSpec;

class AesEncryptionDecryptTextTest {

	private AESEncryption aesEncryption;

	private SecretKey secretKey;

	@BeforeEach
	void setUp() throws NoSuchAlgorithmException {
		aesEncryption = new AESEncryption();
		secretKey = AESEncryption.getSecretEncryptionKey();
	}

	@Test
	@Tag("valid")
	void decryptValidEncryptedText() throws Exception {
		String plainText = "Hello World";
		byte[] cipherText = AESEncryption.encryptText(plainText, secretKey);
		String decryptedText = AESEncryption.decryptText(cipherText, secretKey);
		assertEquals(plainText, decryptedText);
	}

	@Test
	@Tag("invalid")
	void decryptWithIncorrectKey() throws Exception {
		String plainText = "Hello World";
		byte[] cipherText = AESEncryption.encryptText(plainText, secretKey);
		SecretKey incorrectKey = AESEncryption.getSecretEncryptionKey();
		assertThrows(BadPaddingException.class, () -> AESEncryption.decryptText(cipherText, incorrectKey));
	}

	@Test
	@Tag("boundary")
	void decryptEmptyByteArray() {
		byte[] emptyArray = new byte[0];
		assertThrows(IllegalArgumentException.class, () -> AESEncryption.decryptText(emptyArray, secretKey));
	}

	@Test
	@Tag("invalid")
	void decryptWithNullKey() throws Exception {
		String plainText = "Hello World";
		byte[] cipherText = AESEncryption.encryptText(plainText, secretKey);
		assertThrows(InvalidKeyException.class, () -> AESEncryption.decryptText(cipherText, null));
	}

	@Test
	@Tag("invalid")
	void decryptAlteredCiphertext() throws Exception {
		String plainText = "Hello World";
		byte[] cipherText = AESEncryption.encryptText(plainText, secretKey);
		cipherText[0] = (byte) (cipherText[0] ^ 0xFF); // Alter first byte
		assertThrows(AEADBadTagException.class, () -> AESEncryption.decryptText(cipherText, secretKey));
	}

	@ParameterizedTest
	@MethodSource("providePlainTexts")
	@Tag("valid")
	void decryptVariousPlainTexts(String plainText) throws Exception {
		byte[] cipherText = AESEncryption.encryptText(plainText, secretKey);
		String decryptedText = AESEncryption.decryptText(cipherText, secretKey);
		assertEquals(plainText, decryptedText);
	}

	private static Stream<Arguments> providePlainTexts() {
		return Stream.of(Arguments.of(""), Arguments.of("A"),
				Arguments.of("Lorem ipsum dolor sit amet, consectetur adipiscing elit."),
				Arguments.of("1234567890!@#$%^&*()_+"));
	}

}