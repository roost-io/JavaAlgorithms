
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=encrpyter_0c530b4728
ROOST_METHOD_SIG_HASH=encrpyter_54be174d7d

Based on the provided information, here are several test scenarios for the `encrpyter` method in the `ColumnarTranspositionCipher` class:

```
Scenario 1: Basic Encryption with Default Abecedarium

Details:
  TestName: basicEncryptionWithDefaultAbecedarium
  Description: Test the encryption of a simple word using a keyword and the default abecedarium.
Execution:
  Arrange: Prepare a word to encrypt and a keyword.
  Act: Call the encrpyter method with the word, keyword, and null for abecedarium.
  Assert: Verify that the returned string is not null and different from the input word.
Validation:
  This test ensures that the basic encryption functionality works with the default abecedarium. The encrypted word should be different from the input to confirm that encryption has occurred.

Scenario 2: Encryption with Custom Abecedarium

Details:
  TestName: encryptionWithCustomAbecedarium
  Description: Test the encryption using a custom abecedarium to ensure the method respects the provided character set.
Execution:
  Arrange: Prepare a word, a keyword, and a custom abecedarium.
  Act: Call the encrpyter method with all three parameters.
  Assert: Verify that the returned string only contains characters from the custom abecedarium.
Validation:
  This test confirms that the encryption process uses the provided custom abecedarium, ensuring that the method can work with different character sets as required.

Scenario 3: Encryption with Empty Word

Details:
  TestName: encryptionWithEmptyWord
  Description: Test the behavior of the method when provided with an empty string as the word to encrypt.
Execution:
  Arrange: Prepare an empty string as the word, a valid keyword, and use the default abecedarium.
  Act: Call the encrpyter method with these parameters.
  Assert: Verify that the method returns an empty string.
Validation:
  This test checks how the method handles edge cases, specifically an empty input. It's important to ensure that the method doesn't throw an exception and behaves predictably with empty input.

Scenario 4: Encryption with Long Input

Details:
  TestName: encryptionWithLongInput
  Description: Test the encryption of a very long input string to ensure the method can handle large amounts of data.
Execution:
  Arrange: Prepare a very long string (e.g., 10000 characters) as the word, a normal keyword, and use the default abecedarium.
  Act: Call the encrpyter method with these parameters.
  Assert: Verify that the returned string has the same length as the input and is different from the input.
Validation:
  This test ensures that the encryption method can handle large inputs without breaking or losing data. It's crucial for testing the method's performance and reliability with substantial data.

Scenario 5: Encryption with Keyword Longer than Input

Details:
  TestName: encryptionWithKeywordLongerThanInput
  Description: Test the encryption when the keyword is longer than the input word.
Execution:
  Arrange: Prepare a short word and a longer keyword, use the default abecedarium.
  Act: Call the encrpyter method with these parameters.
  Assert: Verify that the method returns an encrypted string and doesn't throw an exception.
Validation:
  This test checks how the method handles the case where the keyword is longer than the input. It's important to ensure that the method still performs encryption correctly and doesn't fail in this edge case.

Scenario 6: Encryption with Special Characters

Details:
  TestName: encryptionWithSpecialCharacters
  Description: Test the encryption of a string containing special characters to ensure they are handled correctly.
Execution:
  Arrange: Prepare a word containing special characters, a normal keyword, and use the default abecedarium.
  Act: Call the encrpyter method with these parameters.
  Assert: Verify that the returned string is encrypted and contains the special characters.
Validation:
  This test ensures that the encryption method can handle special characters without losing or corrupting them. It's important for maintaining data integrity during encryption.
```

These test scenarios cover various aspects of the `encrpyter` method, including normal operation, edge cases, and potential error conditions. They aim to validate the method's functionality across different input types and sizes.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import static org.junit.jupiter.api.Assertions.*;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.stream.Stream;
import org.junit.jupiter.api.*;
import java.util.Objects;

class ColumnarTranspositionCipherEncrpyter854Test {

	@Test
	@Tag("valid")
	void basicEncryptionWithDefaultAbecedarium() {
		String word = "HELLO WORLD";
		String keyword = "KEY";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertNotNull(encrypted);
		assertNotEquals(word, encrypted);
	}

	@Test
	@Tag("valid")
	void encryptionWithCustomAbecedarium() {
		String word = "HELLO";
		String keyword = "KEY";
		String customAbecedarium = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, customAbecedarium);
		assertNotNull(encrypted);
		assertTrue(encrypted.matches("[A-Z]+"));
	}

	@Test
	@Tag("boundary")
	void encryptionWithEmptyWord() {
		String word = "";
		String keyword = "KEY";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertEquals("", encrypted);
	}

	@Test
	@Tag("valid")
	void encryptionWithLongInput() {
		String word = "A".repeat(10000);
		String keyword = "LONGKEY";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertNotNull(encrypted);
		assertEquals(10000, encrypted.length());
		assertNotEquals(word, encrypted);
	}

	@Test
	@Tag("boundary")
	void encryptionWithKeywordLongerThanInput() {
		String word = "SHORT";
		String keyword = "VERYLONGKEYWORD";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertNotNull(encrypted);
		assertNotEquals(word, encrypted);
	}

	@Test
	@Tag("valid")
	void encryptionWithSpecialCharacters() {
		String word = "HELLO!@#$%^&*()";
		String keyword = "KEY";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertNotNull(encrypted);
		assertTrue(encrypted.contains("!@#$%^&*()"));
	}

	@ParameterizedTest
	@MethodSource("provideTestCases")
	@Tag("valid")
	void parameterizedEncryptionTest(String word, String keyword, String abecedarium, String expected) {
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, abecedarium);
		assertEquals(expected, encrypted);
	}

	private static Stream<Arguments> provideTestCases() {
		return Stream.of(Arguments.of("HELLO", "KEY", null, "LEHOL"),
				Arguments.of("WORLD", "SECRET", "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "DLROW"),
				Arguments.of("TEST", "LONG", null, "TTSE"),
				Arguments.of("CRYPTOGRAPHY", "CIPHER", null, "YPCTRRAOPGHY"));
	}

	@Test
	@Tag("invalid")
	void encryptionWithNullWord() {
		assertThrows(NullPointerException.class, () -> {
			ColumnarTranspositionCipher.encrpyter(null, "KEY", null);
		});
	}

	@Test
	@Tag("invalid")
	void encryptionWithNullKeyword() {
		assertThrows(NullPointerException.class, () -> {
			ColumnarTranspositionCipher.encrpyter("HELLO", null, null);
		});
	}

	@Test
	@Tag("boundary")
	void encryptionWithSingleCharacterWord() {
		String word = "A";
		String keyword = "KEY";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertEquals(word, encrypted);
	}

	@Test
	@Tag("boundary")
	void encryptionWithSingleCharacterKeyword() {
		String word = "HELLO";
		String keyword = "K";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertEquals(word, encrypted);
	}

	@Test
	@Tag("valid")
	void encryptionResultDifferentFromInput() {
		String word = "THISISALONGSENTENCE";
		String keyword = "SECRETKEY";
		String encrypted = ColumnarTranspositionCipher.encrpyter(word, keyword, null);
		assertThat(encrypted).isNotEqualTo(word);
	}

}