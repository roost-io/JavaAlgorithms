
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=encode_50249fd5bf
ROOST_METHOD_SIG_HASH=encode_81ca5a284e

Based on the provided Caesar class and its methods, here are several test scenarios for the `encode` method:

```
Scenario 1: Encode a simple message with positive shift

Details:
  TestName: encodeSimpleMessageWithPositiveShift
  Description: Test the encoding of a simple message using a positive shift value.
Execution:
  Arrange: Create a Caesar object and prepare a simple message and shift value.
  Act: Call the encode method with the message and shift.
  Assert: Compare the returned encoded string with the expected result.
Validation:
  Verify that each character in the message is correctly shifted by the given amount. This test ensures the basic functionality of the Caesar cipher for uppercase and lowercase letters.

Scenario 2: Encode a message with shift value greater than 26

Details:
  TestName: encodeMessageWithLargeShift
  Description: Test the encoding of a message using a shift value larger than 26 to ensure proper wrapping.
Execution:
  Arrange: Create a Caesar object and prepare a message with a shift value greater than 26.
  Act: Call the encode method with the message and large shift.
  Assert: Compare the returned encoded string with the expected result.
Validation:
  Confirm that the method correctly handles shift values greater than 26 by wrapping around the alphabet. This tests the modulo operation in the encode method.

Scenario 3: Encode a message with non-alphabetic characters

Details:
  TestName: encodeMessageWithNonAlphabeticChars
  Description: Test the encoding of a message containing non-alphabetic characters to ensure they remain unchanged.
Execution:
  Arrange: Create a Caesar object and prepare a message with mixed alphabetic and non-alphabetic characters.
  Act: Call the encode method with the mixed message and a shift value.
  Assert: Verify that alphabetic characters are shifted and non-alphabetic characters remain unchanged.
Validation:
  Ensure that the method correctly handles non-alphabetic characters by leaving them unmodified in the encoded output.

Scenario 4: Encode an empty message

Details:
  TestName: encodeEmptyMessage
  Description: Test the encoding of an empty message to ensure proper handling of edge cases.
Execution:
  Arrange: Create a Caesar object and prepare an empty string as the message.
  Act: Call the encode method with the empty string and any shift value.
  Assert: Verify that the returned result is also an empty string.
Validation:
  Confirm that the method handles empty input correctly without throwing exceptions or producing unexpected output.

Scenario 5: Encode a message with negative shift

Details:
  TestName: encodeMessageWithNegativeShift
  Description: Test the encoding of a message using a negative shift value to ensure correct leftward shifting.
Execution:
  Arrange: Create a Caesar object and prepare a message with a negative shift value.
  Act: Call the encode method with the message and negative shift.
  Assert: Compare the returned encoded string with the expected result.
Validation:
  Verify that the method correctly handles negative shift values by shifting characters to the left in the alphabet.

Scenario 6: Encode a message with zero shift

Details:
  TestName: encodeMessageWithZeroShift
  Description: Test the encoding of a message with a shift value of zero to ensure the message remains unchanged.
Execution:
  Arrange: Create a Caesar object and prepare a message.
  Act: Call the encode method with the message and a shift value of 0.
  Assert: Verify that the returned string is identical to the input message.
Validation:
  Confirm that a shift of zero results in no changes to the original message, effectively testing the identity property of the Caesar cipher.

Scenario 7: Encode a message with mixed case letters

Details:
  TestName: encodeMessageWithMixedCase
  Description: Test the encoding of a message containing both uppercase and lowercase letters to ensure correct handling of both cases.
Execution:
  Arrange: Create a Caesar object and prepare a message with mixed case letters.
  Act: Call the encode method with the mixed case message and a shift value.
  Assert: Verify that both uppercase and lowercase letters are correctly shifted while maintaining their case.
Validation:
  Ensure that the method correctly distinguishes between and handles both uppercase and lowercase letters, maintaining the original case in the encoded output.
```

These test scenarios cover various aspects of the `encode` method, including basic functionality, edge cases, and potential error conditions. They aim to validate the correct implementation of the Caesar cipher encoding across different input types and shift values.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;

class CaesarEncodeTest {

	private Caesar caesar;

	@BeforeEach
	void setUp() {
		caesar = new Caesar();
	}

	@Test
	@Tag("valid")
	void encodeSimpleMessageWithPositiveShift() {
		String message = "HELLO WORLD";
		int shift = 3;
		String expected = "KHOOR ZRUOG";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("valid")
	void encodeMessageWithLargeShift() {
		String message = "LARGE SHIFT";
		int shift = 53;
		String expected = "MBSHF TIJGU";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("valid")
	void encodeMessageWithNonAlphabeticChars() {
		String message = "Hello, World! 123";
		int shift = 1;
		String expected = "Ifmmp, Xpsme! 123";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("boundary")
	void encodeEmptyMessage() {
		String message = "";
		int shift = 5;
		String expected = "";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("valid")
	void encodeMessageWithNegativeShift() {
		String message = "NEGATIVE SHIFT";
		int shift = -3;
		String expected = "KBDXQFSB PEFCQ";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("boundary")
	void encodeMessageWithZeroShift() {
		String message = "ZERO SHIFT";
		int shift = 0;
		String expected = "ZERO SHIFT";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("valid")
	void encodeMessageWithMixedCase() {
		String message = "MiXeD CaSe";
		int shift = 4;
		String expected = "QmBiH GeSi";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@ParameterizedTest
	@CsvSource({ "HELLO, 1, IFMMP", "world, 2, yqtnf", "Caesar Cipher, 7, Jhlzhy Jpwoly",
			"ABCDEFGHIJKLMNOPQRSTUVWXYZ, 13, NOPQRSTUVWXYZABCDEFGHIJKLM" })
	@Tag("valid")
	void encodeParameterizedTest(String message, int shift, String expected) {
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("boundary")
	void encodeWithFullAlphabetShift() {
		String message = "FULL SHIFT";
		int shift = 26;
		String expected = "FULL SHIFT";
		assertEquals(expected, caesar.encode(message, shift));
	}

	@Test
	@Tag("valid")
	void encodeWithWrappingShift() {
		String message = "WRAPPING";
		int shift = 30;
		String expected = "AVTRRQPI";
		assertEquals(expected, caesar.encode(message, shift));
	}

}