
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=scheduleCore_02d3b3e15a
ROOST_METHOD_SIG_HASH=scheduleCore_39a36839f6

Based on the provided method `scheduleCore` and the given instructions, here are several test scenarios for the AES class:

```
Scenario 1: Basic Functionality Test

Details:
  TestName: basicScheduleCore()
  Description: Verify that the scheduleCore method correctly processes a simple input and returns the expected output.

Execution:
  Arrange:
    - Create a BigInteger input value
    - Set an rconCounter value
  Act:
    - Call scheduleCore(input, rconCounter)
  Assert:
    - Compare the returned BigInteger with the expected output

Validation:
  This test ensures that the basic functionality of scheduleCore works as expected for a known input-output pair. It's crucial for verifying the core algorithm's correctness.

Scenario 2: Zero Input Test

Details:
  TestName: scheduleCorewithZeroInput()
  Description: Test the behavior of scheduleCore when given a zero input.

Execution:
  Arrange:
    - Set input as BigInteger.ZERO
    - Set rconCounter to 1
  Act:
    - Call scheduleCore(BigInteger.ZERO, 1)
  Assert:
    - Verify that the output is not zero and matches the expected transformation of a zero input

Validation:
  This test checks how the method handles edge cases, specifically a zero input. It's important to ensure the method doesn't produce unexpected results or errors with such input.

Scenario 3: Large Input Value Test

Details:
  TestName: scheduleCoreWithLargeInput()
  Description: Test scheduleCore with a large BigInteger input to ensure it handles big numbers correctly.

Execution:
  Arrange:
    - Create a large BigInteger input (e.g., new BigInteger("FFFFFFFFFFFFFFFF", 16))
    - Set rconCounter to a valid value
  Act:
    - Call scheduleCore with the large input
  Assert:
    - Verify that the output is correct and doesn't overflow or lose precision

Validation:
  This test ensures that the method can handle large inputs without issues, which is crucial for the security and reliability of the AES implementation.

Scenario 4: Multiple Rcon Values Test

Details:
  TestName: scheduleCoreWithDifferentRconValues()
  Description: Test scheduleCore with the same input but different rconCounter values to ensure proper RCON application.

Execution:
  Arrange:
    - Create a fixed BigInteger input
    - Prepare an array of different rconCounter values
  Act:
    - Call scheduleCore multiple times with the same input but different rconCounter values
  Assert:
    - Verify that each call produces a unique and correct output

Validation:
  This test checks if the RCON values are correctly applied in the algorithm, which is crucial for the key expansion process in AES.

Scenario 5: Boundary Rcon Value Test

Details:
  TestName: scheduleCoreWithBoundaryRconValue()
  Description: Test scheduleCore with the maximum valid rconCounter value to ensure it doesn't cause issues.

Execution:
  Arrange:
    - Create a valid BigInteger input
    - Set rconCounter to the maximum valid value (based on the RCON array size)
  Act:
    - Call scheduleCore with the input and max rconCounter
  Assert:
    - Verify that the output is correct and no index out of bounds error occurs

Validation:
  This test ensures that the method handles the boundary case of the maximum RCON value correctly, which is important for the robustness of the key expansion process.
```

These test scenarios cover various aspects of the `scheduleCore` method, including basic functionality, edge cases, and potential issues with different inputs and RCON values. They aim to ensure the correctness and robustness of this critical component of the AES implementation.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import static org.assertj.core.api.Assertions.*;
import java.math.BigInteger;
import org.junit.jupiter.api.*;
import java.util.Scanner;

class AesScheduleCoreTest {

	@Test
	@Tag("valid")
	void basicScheduleCore() {
		BigInteger input = new BigInteger("1A2B3C4D", 16);
		int rconCounter = 1;
		BigInteger expected = new BigInteger("B9C2D195", 16);
		BigInteger result = AES.scheduleCore(input, rconCounter);
		assertThat(result).isEqualTo(expected);
	}

	@Test
	@Tag("boundary")
	void scheduleCorewithZeroInput() {
		BigInteger input = BigInteger.ZERO;
		int rconCounter = 1;
		BigInteger result = AES.scheduleCore(input, rconCounter);
		assertThat(result).isNotEqualTo(BigInteger.ZERO);
		assertThat(result).isEqualTo(new BigInteger("63", 16));
	}

	@Test
	@Tag("valid")
	void scheduleCoreWithLargeInput() {
		BigInteger input = new BigInteger("FFFFFFFFFFFFFFFF", 16);
		int rconCounter = 2;
		BigInteger expected = new BigInteger("16161616161616D7", 16);
		BigInteger result = AES.scheduleCore(input, rconCounter);
		assertThat(result).isEqualTo(expected);
	}

	@ParameterizedTest
	@CsvSource({ "1A2B3C4D, 1, B9C2D195", "1A2B3C4D, 2, B9C2D197", "1A2B3C4D, 3, B9C2D192", "1A2B3C4D, 4, B9C2D19C" })
	@Tag("valid")
	void scheduleCoreWithDifferentRconValues(String input, int rconCounter, String expected) {
		BigInteger inputBigInt = new BigInteger(input, 16);
		BigInteger expectedBigInt = new BigInteger(expected, 16);
		BigInteger result = AES.scheduleCore(inputBigInt, rconCounter);
		assertThat(result).isEqualTo(expectedBigInt);
	}

	@Test
	@Tag("boundary")
	void scheduleCoreWithBoundaryRconValue() {
		BigInteger input = new BigInteger("1A2B3C4D", 16);
		int rconCounter = 255; // Assuming RCON array has 256 elements
		BigInteger result = AES.scheduleCore(input, rconCounter);
		assertThat(result).isNotNull();
		// The exact expected value would depend on the RCON array's last value
	}

	@Test
	@Tag("invalid")
	void scheduleCoreWithNegativeRconValue() {
		BigInteger input = new BigInteger("1A2B3C4D", 16);
		int rconCounter = -1;
		assertThatThrownBy(() -> AES.scheduleCore(input, rconCounter))
			.isInstanceOf(ArrayIndexOutOfBoundsException.class);
	}

	@Test
	@Tag("valid")
	void scheduleCoreRotationCheck() {
		BigInteger input = new BigInteger("ABCDEF01", 16);
		int rconCounter = 1;
		BigInteger result = AES.scheduleCore(input, rconCounter);
		// Check if the rotation happened (first byte should now be at the end)
		assertThat(result.toString(16).toLowerCase()).endsWith("ab");
	}

	@Test
	@Tag("valid")
	void scheduleCoreSubstitutionCheck() {
		BigInteger input = new BigInteger("00112233", 16);
		int rconCounter = 1;
		BigInteger result = AES.scheduleCore(input, rconCounter);
		// The first byte (00) should be substituted and XORed with RCON[1]
		// The exact value depends on the S-Box and RCON values
		assertThat(result.toString(16).toLowerCase()).doesNotStartWith("00");
	}

}