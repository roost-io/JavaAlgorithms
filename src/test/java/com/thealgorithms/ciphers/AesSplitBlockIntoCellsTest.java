
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=splitBlockIntoCells_3071ee55e5
ROOST_METHOD_SIG_HASH=splitBlockIntoCells_6d08d743a1

Based on the provided method `splitBlockIntoCells` and the given instructions, here are several test scenarios:

Scenario 1: Split a 128-bit block into 16 8-bit cells

Details:
  TestName: splitBlockIntoCellsNormalCase
  Description: Test the normal case where a 128-bit BigInteger is split into 16 8-bit cells.
Execution:
  Arrange: Create a BigInteger with a known 128-bit value.
  Act: Call splitBlockIntoCells with the created BigInteger.
  Assert: Verify that the returned array has 16 elements and each element is correctly split.
Validation:
  This test ensures that the method correctly splits a 128-bit block into 16 8-bit cells. It's crucial for the proper functioning of the AES algorithm as it relies on this cell structure for various operations.

Scenario 2: Split a BigInteger with leading zeros

Details:
  TestName: splitBlockIntoCellsWithLeadingZeros
  Description: Test the case where the input BigInteger has leading zeros but still represents a 128-bit value.
Execution:
  Arrange: Create a BigInteger with a value that has leading zeros when represented in binary.
  Act: Call splitBlockIntoCells with this BigInteger.
  Assert: Verify that the returned array has 16 elements and the leading elements are zero.
Validation:
  This test verifies that the method correctly handles inputs with leading zeros, ensuring that the 128-bit structure is maintained even when the actual value doesn't use all bits.

Scenario 3: Split the minimum 128-bit value (all zeros)

Details:
  TestName: splitBlockIntoCellsAllZeros
  Description: Test the edge case where the input is the minimum 128-bit value (all zeros).
Execution:
  Arrange: Create a BigInteger with value zero.
  Act: Call splitBlockIntoCells with this BigInteger.
  Assert: Verify that the returned array has 16 elements, all of which are zero.
Validation:
  This test checks the method's behavior with the minimum possible 128-bit value, ensuring it correctly handles this edge case without errors.

Scenario 4: Split the maximum 128-bit value (all ones)

Details:
  TestName: splitBlockIntoCellsAllOnes
  Description: Test the edge case where the input is the maximum 128-bit value (all ones).
Execution:
  Arrange: Create a BigInteger with all 128 bits set to 1.
  Act: Call splitBlockIntoCells with this BigInteger.
  Assert: Verify that the returned array has 16 elements, all of which are 255 (binary 11111111).
Validation:
  This test verifies the method's behavior with the maximum possible 128-bit value, ensuring it correctly handles this edge case and properly splits the bits.

Scenario 5: Split a BigInteger with alternating bit pattern

Details:
  TestName: splitBlockIntoCellsAlternatingBits
  Description: Test with a BigInteger that has an alternating bit pattern (1010...) to ensure correct bit handling.
Execution:
  Arrange: Create a BigInteger with an alternating bit pattern for all 128 bits.
  Act: Call splitBlockIntoCells with this BigInteger.
  Assert: Verify that the returned array has 16 elements, each alternating between 170 (10101010) and 85 (01010101).
Validation:
  This test ensures that the method correctly handles and splits a complex bit pattern, verifying its accuracy in bit manipulation and division.

These scenarios cover normal cases, edge cases, and specific patterns to thoroughly test the `splitBlockIntoCells` method. They focus on the method's ability to correctly split a 128-bit BigInteger into an array of 16 8-bit integers under various conditions.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.assertj.core.api.Assertions.assertThat;
import java.math.BigInteger;
import org.junit.jupiter.api.*;
import java.util.Scanner;

class AesSplitBlockIntoCellsTest {

	@Test
	@Tag("valid")
	void splitBlockIntoCellsNormalCase() {
		BigInteger input = new BigInteger("123456789ABCDEF0123456789ABCDEF", 16);
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result[0]).isEqualTo(0x12);
		assertThat(result[15]).isEqualTo(0xEF);
	}

	@Test
	@Tag("valid")
	void splitBlockIntoCellsWithLeadingZeros() {
		BigInteger input = new BigInteger("0000123456789ABCDEF0123456789ABCDEF", 16);
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result[0]).isEqualTo(0x00);
		assertThat(result[1]).isEqualTo(0x00);
		assertThat(result[2]).isEqualTo(0x12);
	}

	@Test
	@Tag("boundary")
	void splitBlockIntoCellsAllZeros() {
		BigInteger input = BigInteger.ZERO;
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result).containsOnly(0);
	}

	@Test
	@Tag("boundary")
	void splitBlockIntoCellsAllOnes() {
		BigInteger input = BigInteger.ONE.shiftLeft(128).subtract(BigInteger.ONE);
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result).containsOnly(255);
	}

	@Test
	@Tag("valid")
	void splitBlockIntoCellsAlternatingBits() {
		BigInteger input = new BigInteger("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 16);
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result).containsOnly(170);
	}

	@Test
	@Tag("valid")
	void splitBlockIntoCellsRandomValue() {
		BigInteger input = new BigInteger("9876543210FEDCBA9876543210FEDCBA", 16);
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result[0]).isEqualTo(0x98);
		assertThat(result[7]).isEqualTo(0xBA);
		assertThat(result[8]).isEqualTo(0x98);
		assertThat(result[15]).isEqualTo(0xBA);
	}

	@Test
	@Tag("boundary")
	void splitBlockIntoCellsMinimumNonZeroValue() {
		BigInteger input = BigInteger.ONE;
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result[15]).isEqualTo(1);
		assertThat(result).startsWith(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	}

	@Test
	@Tag("boundary")
	void splitBlockIntoCellsMaximumValueMinusOne() {
		BigInteger input = BigInteger.ONE.shiftLeft(128).subtract(BigInteger.TWO);
		int[] result = AES.splitBlockIntoCells(input);

		assertThat(result).hasSize(16);
		assertThat(result).startsWith(255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255);
		assertThat(result[15]).isEqualTo(254);
	}

}