
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unitdemo using AI Type  and AI Model

ROOST_METHOD_HASH=encryptText_b51f222638
ROOST_METHOD_SIG_HASH=encryptText_ff3ca8788e

Based on the provided information, here are several test scenarios for the `encryptText` method in the `AESEncryption` class:

```
Scenario 1: Successful Encryption of Plain Text

Details:
  TestName: encryptPlainText
  Description: Verify that the encryptText method successfully encrypts a given plain text using a provided secret key.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Prepare a plain text string
  Act:
    - Call encryptText with the plain text and secret key
  Assert:
    - Verify that the returned byte array is not null
    - Verify that the returned byte array is not empty
    - Verify that the returned byte array is different from the original plain text bytes

Validation:
  This test ensures that the encryption process produces a non-null, non-empty result that differs from the original input. It validates the basic functionality of the encryption method.

Scenario 2: Encryption with Empty String

Details:
  TestName: encryptEmptyString
  Description: Test the behavior of encryptText when given an empty string as input.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Prepare an empty string
  Act:
    - Call encryptText with the empty string and secret key
  Assert:
    - Verify that the method returns a non-null byte array
    - Verify that the returned byte array is not empty

Validation:
  This test checks how the encryption method handles an edge case of an empty input string. It ensures that the method doesn't throw an exception and produces some output even for empty input.

Scenario 3: Encryption with Null Secret Key

Details:
  TestName: encryptWithNullSecretKey
  Description: Verify that the encryptText method throws an InvalidKeyException when provided with a null secret key.

Execution:
  Arrange:
    - Prepare a plain text string
    - Set the secret key to null
  Act:
    - Call encryptText with the plain text and null secret key
  Assert:
    - Verify that an InvalidKeyException is thrown

Validation:
  This test ensures that the method properly handles and reports errors when given invalid input (null secret key). It's crucial for maintaining the security and integrity of the encryption process.

Scenario 4: Encryption with Large Plain Text

Details:
  TestName: encryptLargePlainText
  Description: Test the encryption of a large plain text to ensure the method can handle substantial input.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Prepare a large plain text string (e.g., 1MB of text)
  Act:
    - Call encryptText with the large plain text and secret key
  Assert:
    - Verify that the returned byte array is not null
    - Verify that the length of the returned byte array is appropriate for the input size

Validation:
  This test verifies that the encryption method can handle large inputs without throwing exceptions or producing unexpected results. It's important for ensuring the method's robustness in real-world scenarios with varying input sizes.

Scenario 5: Encryption Consistency

Details:
  TestName: encryptionConsistency
  Description: Verify that encrypting the same plain text with the same key multiple times produces the same result.

Execution:
  Arrange:
    - Generate a secret key using getSecretEncryptionKey()
    - Prepare a plain text string
  Act:
    - Call encryptText twice with the same plain text and secret key
  Assert:
    - Verify that both encrypted results are identical

Validation:
  This test ensures the consistency and deterministic nature of the encryption process. It's crucial for verifying that the encryption method produces reliable and repeatable results under the same conditions.
```

These scenarios cover various aspects of the `encryptText` method, including normal operation, edge cases, error handling, and performance with large inputs. They aim to thoroughly test the method's functionality and robustness.
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.junit.jupiter.api.Assertions.*;
import javax.crypto.SecretKey;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import org.junit.jupiter.api.*;
import java.security.InvalidAlgorithmParameterException;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.spec.GCMParameterSpec;

class AesEncryptionEncryptTextTest {

	private SecretKey secretKey;

	@BeforeEach
	void setUp() throws NoSuchAlgorithmException {
		secretKey = AESEncryption.getSecretEncryptionKey();
	}

	@Test
	@Tag("valid")
	void encryptPlainText() throws Exception {
		String plainText = "Hello World";
		byte[] encryptedText = AESEncryption.encryptText(plainText, secretKey);
		assertNotNull(encryptedText);
		assertTrue(encryptedText.length > 0);
		assertFalse(Arrays.equals(encryptedText, plainText.getBytes()));
	}

	@Test
	@Tag("boundary")
	void encryptEmptyString() throws Exception {
		String emptyString = "";
		byte[] encryptedText = AESEncryption.encryptText(emptyString, secretKey);
		assertNotNull(encryptedText);
		assertTrue(encryptedText.length > 0);
	}

	@Test
	@Tag("invalid")
	void encryptWithNullSecretKey() {
		String plainText = "Test Text";
		assertThrows(InvalidKeyException.class, () -> AESEncryption.encryptText(plainText, null));
	}

	@Test
	@Tag("boundary")
	void encryptLargePlainText() throws Exception {
		StringBuilder largeTextBuilder = new StringBuilder();
		for (int i = 0; i < 100000; i++) {
			largeTextBuilder.append("Lorem ipsum dolor sit amet. ");
		}
		String largeText = largeTextBuilder.toString();
		byte[] encryptedText = AESEncryption.encryptText(largeText, secretKey);
		assertNotNull(encryptedText);
		assertTrue(encryptedText.length > largeText.length());
	}

	@Test
	@Tag("valid")
	void encryptionConsistency() throws Exception {
		String plainText = "Consistent Encryption Test";
		byte[] firstEncryption = AESEncryption.encryptText(plainText, secretKey);
		byte[] secondEncryption = AESEncryption.encryptText(plainText, secretKey);
		assertArrayEquals(firstEncryption, secondEncryption);
	}

	@ParameterizedTest
	@Tag("valid")
	@ValueSource(strings = { "Hello", "OpenAI", "Encryption", "Test" })
	void encryptVariousStrings(String input) throws Exception {
		byte[] encryptedText = AESEncryption.encryptText(input, secretKey);
		assertNotNull(encryptedText);
		assertTrue(encryptedText.length > 0);
		assertFalse(Arrays.equals(encryptedText, input.getBytes()));
	}

	@Test
	@Tag("invalid")
	void encryptNullPlainText() {
		assertThrows(NullPointerException.class, () -> AESEncryption.encryptText(null, secretKey));
	}

}