

// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=storeAllPaths_5448c785f8
ROOST_METHOD_SIG_HASH=storeAllPaths_0b9f8673ad

"""
  Scenario 1: Test the method with valid source and destination nodes

  Details:  
    TestName: testStoreAllPathsWithValidNodes.
    Description: The test checks if the method storeAllPaths correctly stores all paths from the source node to the destination node for a valid input case. 
  Execution:
    Arrange: Create an instance of AllPathsFromSourceToTarget with a defined number of vertices. Create an adjacency matrix and add edges to the graph. Define the source and destination nodes.
    Act: Call the method storeAllPaths with the source and destination nodes.
    Assert: Use JUnit assertions to check if the method has stored all possible paths from the source to the destination.
  Validation: 
    The assertion verifies that the method correctly stores all paths from the source to the destination. The test confirms the method's ability to handle normal, valid input.

  Scenario 2: Test the method with source and destination nodes being the same

  Details:  
    TestName: testStoreAllPathsWithSameNodes.
    Description: The test checks if the method storeAllPaths correctly handles the scenario where the source and destination nodes are the same.
  Execution:
    Arrange: Create an instance of AllPathsFromSourceToTarget with a defined number of vertices. Create an adjacency matrix and add edges to the graph. Define the source and destination nodes as the same.
    Act: Call the method storeAllPaths with the source and destination nodes.
    Assert: Use JUnit assertions to check if the method has stored the correct path (which is a single node path in this case).
  Validation: 
    The assertion verifies that the method correctly handles the scenario where the source and destination nodes are the same. The test confirms the method's ability to handle edge cases.

  Scenario 3: Test the method with the destination node unreachable from the source

  Details:  
    TestName: testStoreAllPathsWithUnreachableDestination.
    Description: The test checks if the method storeAllPaths correctly handles the scenario where the destination node is unreachable from the source node.
  Execution:
    Arrange: Create an instance of AllPathsFromSourceToTarget with a defined number of vertices. Create an adjacency matrix and add edges to the graph in a way that the destination node is unreachable from the source. Define the source and destination nodes.
    Act: Call the method storeAllPaths with the source and destination nodes.
    Assert: Use JUnit assertions to check if the method returns an empty array (since there are no paths from the source to the destination).
  Validation: 
    The assertion verifies that the method correctly handles the scenario where the destination node is unreachable from the source node. The test confirms the method's error handling capabilities.
"""
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.List;

public class AllPathsFromSourceToTargetStoreAllPathsTest {
    @Test
    @Tag("valid")
    public void testStoreAllPathsWithValidNodes() {
        // Arrange
        int vertices = 4;
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(vertices);
        int[][] adjacencyMatrix = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}};
        for (int[] edge : adjacencyMatrix) {
            graph.addEdge(edge[0], edge[1]);
        }
        int source = 2;
        int destination = 3;
        // Act
        graph.storeAllPaths(source, destination);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.nm;
        // Assert
        assertFalse(paths.isEmpty(), "The paths list should not be empty");
        assertEquals(2, paths.size(), "There should be two paths from source to destination");
    }
    @Test
    @Tag("boundary")
    public void testStoreAllPathsWithSameNodes() {
        // Arrange
        int vertices = 3;
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(vertices);
        int[][] adjacencyMatrix = {{0, 1}, {0, 2}, {1, 2}};
        for (int[] edge : adjacencyMatrix) {
            graph.addEdge(edge[0], edge[1]);
        }
        int source = 1;
        int destination = 1;
        // Act
        graph.storeAllPaths(source, destination);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.nm;
        // Assert
        assertFalse(paths.isEmpty(), "The paths list should not be empty");
        assertEquals(1, paths.size(), "There should be one path from source to destination");
        assertEquals(source, paths.get(0).get(0), "The only path should be the source node itself");
    }
    @Test
    @Tag("invalid")
    public void testStoreAllPathsWithUnreachableDestination() {
        // Arrange
        int vertices = 3;
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(vertices);
        int[][] adjacencyMatrix = {{0, 1}, {1, 2}};
        for (int[] edge : adjacencyMatrix) {
            graph.addEdge(edge[0], edge[1]);
        }
        int source = 2;
        int destination = 0;
        // Act
        graph.storeAllPaths(source, destination);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.nm;
        // Assert
        assertTrue(paths.isEmpty(), "The paths list should be empty as the destination is unreachable from source");
    }
}