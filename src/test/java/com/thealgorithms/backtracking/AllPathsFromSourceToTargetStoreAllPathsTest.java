

// ********RoostGPT********
/*
Test generated by RoostGPT for test JiraTest using AI Type  and AI Model 

ROOST_METHOD_HASH=storeAllPaths_5448c785f8
ROOST_METHOD_SIG_HASH=storeAllPaths_0b9f8673ad

"""
Scenario 1: Test the method with valid source and destination nodes

Details:  
  TestName: testValidSourceAndDestination.
  Description: This test is designed to verify that the method storeAllPaths correctly identifies and stores all paths from the source node to the destination node in a graph. 
Execution:
  Arrange: Initialize an instance of AllPathsFromSourceToTarget with a valid graph. Define a source and destination node that have multiple paths between them. 
  Act: Call the storeAllPaths method with the defined source and destination nodes.
  Assert: Use JUnit assertions to verify that the returned list of paths matches the expected paths.
Validation: 
  This test verifies that the method correctly identifies and stores all paths from the source node to the destination node. This is essential for ensuring that the application can accurately traverse graphs.

Scenario 2: Test the method with a source node that is not connected to the destination node

Details:  
  TestName: testSourceNotConnectedToDestination.
  Description: This test is designed to verify that the method storeAllPaths correctly handles cases where the source node is not connected to the destination node.
Execution:
  Arrange: Initialize an instance of AllPathsFromSourceToTarget with a valid graph. Define a source node and a destination node such that there is no path from the source to the destination.
  Act: Call the storeAllPaths method with the defined source and destination nodes.
  Assert: Use JUnit assertions to verify that the returned list of paths is empty.
Validation: 
  This test verifies that the method correctly handles cases where the source node is not connected to the destination node. This is important for ensuring that the application can accurately handle graphs with disconnected nodes.

Scenario 3: Test the method with a source node equal to the destination node

Details:  
  TestName: testSourceEqualToDestination.
  Description: This test is designed to verify that the method storeAllPaths correctly handles cases where the source node is the same as the destination node.
Execution:
  Arrange: Initialize an instance of AllPathsFromSourceToTarget with a valid graph. Define a source node and a destination node such that they are the same node.
  Act: Call the storeAllPaths method with the defined source and destination nodes.
  Assert: Use JUnit assertions to verify that the returned list of paths contains a single path that starts and ends at the defined node.
Validation: 
  This test verifies that the method correctly handles cases where the source node is the same as the destination node. This is important for ensuring that the application can accurately handle graphs with self-loops.
"""
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

public class AllPathsFromSourceToTargetStoreAllPathsTest {
    @Test
    @Tag("valid")
    public void testValidSourceAndDestination() {
        int vertices = 4;
        int[][] edges = {{0, 1}, {0, 2}, {0, 3}, {2, 1}, {2, 3}};
        int source = 0;
        int destination = 3;
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(vertices);
        for (int[] edge : edges) {
            graph.addEdge(edge[0], edge[1]);
        }
        graph.storeAllPaths(source, destination);
        List<List<Integer>> expectedPaths = new ArrayList<>();
        expectedPaths.add(Arrays.asList(0, 1));
        expectedPaths.add(Arrays.asList(0, 2, 1));
        expectedPaths.add(Arrays.asList(0, 2, 3));
        expectedPaths.add(Arrays.asList(0, 3));
        assertEquals(expectedPaths, AllPathsFromSourceToTarget.nm);
    }
    @Test
    @Tag("invalid")
    public void testSourceNotConnectedToDestination() {
        int vertices = 4;
        int[][] edges = {{0, 1}, {1, 2}, {2, 3}};
        int source = 0;
        int destination = 3;
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(vertices);
        for (int[] edge : edges) {
            graph.addEdge(edge[0], edge[1]);
        }
        graph.storeAllPaths(source, destination);
        List<List<Integer>> expectedPaths = new ArrayList<>();
        expectedPaths.add(Arrays.asList(0, 1, 2, 3));
        assertEquals(expectedPaths, AllPathsFromSourceToTarget.nm);
    }
    @Test
    @Tag("boundary")
    public void testSourceEqualToDestination() {
        int vertices = 4;
        int[][] edges = {{0, 1}, {1, 2}, {2, 3}};
        int source = 0;
        int destination = 0;
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(vertices);
        for (int[] edge : edges) {
            graph.addEdge(edge[0], edge[1]);
        }
        graph.storeAllPaths(source, destination);
        List<List<Integer>> expectedPaths = new ArrayList<>();
        expectedPaths.add(Arrays.asList(0));
        assertEquals(expectedPaths, AllPathsFromSourceToTarget.nm);
    }
}