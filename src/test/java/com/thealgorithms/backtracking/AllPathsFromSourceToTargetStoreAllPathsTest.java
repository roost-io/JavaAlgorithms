// ********RoostGPT********
/*
Test generated by RoostGPT for test testmenow using AI Type  and AI Model 

ROOST_METHOD_HASH=storeAllPaths_5448c785f8
ROOST_METHOD_SIG_HASH=storeAllPaths_0b9f8673ad

Here are the test scenarios for the `storeAllPaths` method:

**Scenario 1: Happy Path with Valid Source and Destination**

Details:
TestName: storeAllPathsValidSourceAndDestination
Description: This test checks if the `storeAllPaths` method correctly stores all paths from a valid source to a valid destination in a graph.

Execution:
Arrange: Create an instance of `AllPathsFromSourceToTarget` with 5 vertices. Add edges to form a simple graph. Set the source to 0 and the destination to 4.
Act: Call the `storeAllPaths` method with the source and destination.
Assert: Verify that the `nm` list contains all possible paths from the source to the destination.

Validation:
This test ensures that the `storeAllPaths` method works correctly for a valid source and destination. The assertion checks if all possible paths are stored in the `nm` list, which is the expected behavior.

**Scenario 2: Invalid Source Vertex**

Details:
TestName: storeAllPathsInvalidSourceVertex
Description: This test checks if the `storeAllPaths` method handles an invalid source vertex.

Execution:
Arrange: Create an instance of `AllPathsFromSourceToTarget` with 5 vertices. Set the source to -1 and the destination to 4.
Act: Call the `storeAllPaths` method with the source and destination.
Assert: Verify that an `ArrayIndexOutOfBoundsException` is thrown.

Validation:
This test ensures that the `storeAllPaths` method handles invalid source vertices correctly. The assertion checks if an `ArrayIndexOutOfBoundsException` is thrown, which is the expected behavior.

**Scenario 3: Invalid Destination Vertex**

Details:
TestName: storeAllPathsInvalidDestinationVertex
Description: This test checks if the `storeAllPaths` method handles an invalid destination vertex.

Execution:
Arrange: Create an instance of `AllPathsFromSourceToTarget` with 5 vertices. Set the source to 0 and the destination to 5.
Act: Call the `storeAllPaths` method with the source and destination.
Assert: Verify that an `ArrayIndexOutOfBoundsException` is thrown.

Validation:
This test ensures that the `storeAllPaths` method handles invalid destination vertices correctly. The assertion checks if an `ArrayIndexOutOfBoundsException` is thrown, which is the expected behavior.

**Scenario 4: Source and Destination are the Same**

Details:
TestName: storeAllPathsSourceAndDestinationAreTheSame
Description: This test checks if the `storeAllPaths` method handles the case where the source and destination are the same.

Execution:
Arrange: Create an instance of `AllPathsFromSourceToTarget` with 5 vertices. Set the source to 0 and the destination to 0.
Act: Call the `storeAllPaths` method with the source and destination.
Assert: Verify that the `nm` list contains only one path, which is the source vertex itself.

Validation:
This test ensures that the `storeAllPaths` method handles the case where the source and destination are the same correctly. The assertion checks if the `nm` list contains only one path, which is the expected behavior.

**Scenario 5: Graph with No Edges**

Details:
TestName: storeAllPathsGraphWithNoEdges
Description: This test checks if the `storeAllPaths` method handles a graph with no edges.

Execution:
Arrange: Create an instance of `AllPathsFromSourceToTarget` with 5 vertices. Do not add any edges.
Act: Call the `storeAllPaths` method with a valid source and destination.
Assert: Verify that the `nm` list is empty.

Validation:
This test ensures that the `storeAllPaths` method handles a graph with no edges correctly. The assertion checks if the `nm` list is empty, which is the expected behavior.

**Scenario 6: Graph with Multiple Paths**

Details:
TestName: storeAllPathsGraphWithMultiplePaths
Description: This test checks if the `storeAllPaths` method correctly stores all paths in a graph with multiple paths.

Execution:
Arrange: Create an instance of `AllPathsFromSourceToTarget` with 5 vertices. Add edges to form a graph with multiple paths. Set the source to 0 and the destination to 4.
Act: Call the `storeAllPaths` method with the source and destination.
Assert: Verify that the `nm` list contains all possible paths from the source to the destination.

Validation:
This test ensures that the `storeAllPaths` method works correctly for a graph with multiple paths. The assertion checks if all possible paths are stored in the `nm` list, which is the expected behavior.
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.*;

public class AllPathsFromSourceToTargetStoreAllPathsTest {
    @Test
    @Tag("valid")
    public void storeAllPathsValidSourceAndDestination() {
        AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(5);
        allPathsFromSourceToTarget.addEdge(0, 1);
        allPathsFromSourceToTarget.addEdge(0, 2);
        allPathsFromSourceToTarget.addEdge(1, 3);
        allPathsFromSourceToTarget.addEdge(2, 3);
        allPathsFromSourceToTarget.addEdge(3, 4);
        allPathsFromSourceToTarget.storeAllPaths(0, 4);
        List<List<Integer>> actual = AllPathsFromSourceToTarget.nm;
        assertTrue(actual.size() > 0);
    }
    @Test
    @Tag("invalid")
    public void storeAllPathsInvalidSourceVertex() {
        AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(5);
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> allPathsFromSourceToTarget.storeAllPaths(-1, 4));
    }
    @Test
    @Tag("invalid")
    public void storeAllPathsInvalidDestinationVertex() {
        AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(5);
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> allPathsFromSourceToTarget.storeAllPaths(0, 5));
    }
    @Test
    @Tag("boundary")
    public void storeAllPathsSourceAndDestinationAreTheSame() {
        AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(5);
        allPathsFromSourceToTarget.storeAllPaths(0, 0);
        List<List<Integer>> actual = AllPathsFromSourceToTarget.nm;
        assertEquals(1, actual.size());
        assertEquals(1, actual.get(0).size());
        assertEquals(0, (int) actual.get(0).get(0));
    }
    @Test
    @Tag("valid")
    public void storeAllPathsGraphWithNoEdges() {
        AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(5);
        allPathsFromSourceToTarget.storeAllPaths(0, 4);
        List<List<Integer>> actual = AllPathsFromSourceToTarget.nm;
        assertTrue(actual.isEmpty());
    }
    @Test
    @Tag("integration")
    public void storeAllPathsGraphWithMultiplePaths() {
        AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(5);
        allPathsFromSourceToTarget.addEdge(0, 1);
        allPathsFromSourceToTarget.addEdge(0, 2);
        allPathsFromSourceToTarget.addEdge(1, 3);
        allPathsFromSourceToTarget.addEdge(2, 3);
        allPathsFromSourceToTarget.addEdge(3, 4);
        allPathsFromSourceToTarget.addEdge(1, 4);
        allPathsFromSourceToTarget.storeAllPaths(0, 4);
        List<List<Integer>> actual = AllPathsFromSourceToTarget.nm;
        assertTrue(actual.size() > 1);
    }
}