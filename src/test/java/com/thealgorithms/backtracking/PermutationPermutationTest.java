

// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=permutation_e281b55d5b
ROOST_METHOD_SIG_HASH=permutation_90fdaada03

"""
Scenario 1: Test Permutation Method With Null Array Input

Details:  
  TestName: testPermutationWithNullInput
  Description: This test is designed to check the behavior of the permutation method when a null array is passed as an input. 
Execution:
  Arrange: Pass a null array as an input.
  Act: Invoke the permutation method with the null array.
  Assert: Use JUnit assertions to expect a NullPointerException.
Validation: 
  The assertion aims to verify that the method throws a NullPointerException when a null array is passed. This is important to ensure that the method handles null inputs gracefully.

Scenario 2: Test Permutation Method With Empty Array Input

Details:  
  TestName: testPermutationWithEmptyInput
  Description: This test is designed to check the behavior of the permutation method when an empty array is passed as an input. 
Execution:
  Arrange: Pass an empty array as an input.
  Act: Invoke the permutation method with the empty array.
  Assert: Use JUnit assertions to expect an empty list as the result.
Validation: 
  The assertion aims to verify that the method returns an empty list when an empty array is passed. This ensures that the method can handle and return valid results for edge-case inputs.

Scenario 3: Test Permutation Method With Single Element Array Input

Details:  
  TestName: testPermutationWithSingleElement
  Description: This test is designed to check the behavior of the permutation method when a single element array is passed as an input.
Execution:
  Arrange: Pass a single element array as an input.
  Act: Invoke the permutation method with the single element array.
  Assert: Use JUnit assertions to expect a list containing the single element array as the result.
Validation: 
  The assertion aims to verify that the method returns a list containing the single element array when a single element array is passed. This ensures that the method can handle and return valid results for edge-case inputs.

Scenario 4: Test Permutation Method With Multiple Element Array Input

Details:  
  TestName: testPermutationWithMultipleElements
  Description: This test is designed to check the behavior of the permutation method when a multiple element array is passed as an input.
Execution:
  Arrange: Pass a multiple element array as an input.
  Act: Invoke the permutation method with the multiple element array.
  Assert: Use JUnit assertions to expect a list containing all possible permutations of the array as the result.
Validation: 
  The assertion aims to verify that the method returns a list containing all possible permutations of the array when a multiple element array is passed. This ensures that the method correctly calculates all permutations of an array.

Scenario 5: Test Permutation Method With Large Array Input

Details:  
  TestName: testPermutationWithLargeInput
  Description: This test is designed to check the performance and behavior of the permutation method when a large array is passed as an input.
Execution:
  Arrange: Pass a large array as an input.
  Act: Invoke the permutation method with the large array.
  Assert: Use JUnit assertions to ensure that the method returns within a reasonable amount of time.
Validation: 
  The assertion aims to verify that the method can handle large inputs and returns within a reasonable amount of time. This is important for testing the scalability and performance of the method.
"""
*/

// ********RoostGPT********
package com.thealgorithms.backtracking;import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import java.util.Arrays;
import java.util.List;
import java.time.Duration;
import static org.junit.jupiter.api.Assertions.*;
import java.util.LinkedList;

class PermutationPermutationTest {
    @Test
    @Tag("invalid")
    void testPermutationWithNullInput() {
        assertThrows(NullPointerException.class, () -> Permutation.permutation(null));
    }
    @Test
    @Tag("boundary")
    void testPermutationWithEmptyInput() {
        Integer[] array = new Integer[0];
        List<Integer[]> result = Permutation.permutation(array);
        assertTrue(result.isEmpty());
    }
    @Test
    @Tag("boundary")
    void testPermutationWithSingleElement() {
        Integer[] array = {1};
        List<Integer[]> result = Permutation.permutation(array);
        assertEquals(1, result.size());
        assertArrayEquals(array, result.get(0));
    }
    @Test
    @Tag("valid")
    void testPermutationWithMultipleElements() {
        Integer[] array = {1, 2, 3};
        List<Integer[]> result = Permutation.permutation(array);
        assertEquals(6, result.size());
        assertTrue(result.stream().anyMatch(arr -> Arrays.equals(new Integer[]{1, 2, 3}, arr)));
        assertTrue(result.stream().anyMatch(arr -> Arrays.equals(new Integer[]{1, 3, 2}, arr)));
        assertTrue(result.stream().anyMatch(arr -> Arrays.equals(new Integer[]{2, 1, 3}, arr)));
        assertTrue(result.stream().anyMatch(arr -> Arrays.equals(new Integer[]{2, 3, 1}, arr)));
        assertTrue(result.stream().anyMatch(arr -> Arrays.equals(new Integer[]{3, 1, 2}, arr)));
        assertTrue(result.stream().anyMatch(arr -> Arrays.equals(new Integer[]{3, 2, 1}, arr)));
    }
    @Test
    @Tag("integration")
    void testPermutationWithLargeInput() {
        Integer[] array = new Integer[1000];
        for (int i = 0; i < 1000; i++) {
            array[i] = i;
        }
        assertTimeoutPreemptively(Duration.ofMinutes(1), () -> Permutation.permutation(array));
    }
}