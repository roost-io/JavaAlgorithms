

// ********RoostGPT********
/*
Test generated by RoostGPT for test JiraTest using AI Type  and AI Model 

ROOST_METHOD_HASH=allPathsFromSourceToTarget_cbfd384f14
ROOST_METHOD_SIG_HASH=allPathsFromSourceToTarget_5946a30114

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/JiraTest/88343c45-797c-4f0a-8514-42499a9a05ee/source/JavaAlgorithms/src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java
Tests:
    "@Test
@Test
void testForFirstCase() {
    int vertices = 4;
    int[][] a = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 2, 0 }, { 2, 1 }, { 1, 3 } };
    int source = 2;
    int destination = 3;
    List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
    "@Test
@Test
void testForSecondCase() {
    int vertices = 5;
    int[][] a = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 2, 0 }, { 2, 1 }, { 1, 3 }, { 1, 4 }, { 3, 4 }, { 2, 4 } };
    int source = 0;
    int destination = 4;
    List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4), List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
    "@Test
@Test
void testForThirdCase() {
    int vertices = 6;
    int[][] a = { { 1, 0 }, { 2, 3 }, { 0, 4 }, { 1, 5 }, { 4, 3 }, { 0, 2 }, { 0, 3 }, { 1, 2 }, { 0, 5 }, { 3, 4 }, { 2, 5 }, { 2, 4 } };
    int source = 1;
    int destination = 5;
    List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
    "@Test
@Test
void testForFourthcase() {
    int vertices = 3;
    int[][] a = { { 0, 1 }, { 0, 2 }, { 1, 2 } };
    int source = 0;
    int destination = 2;
    List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
""""
Scenario 1: Testing allPathsFromSourceToTarget with a simple graph and direct path from source to destination.

Details:  
  TestName: testDirectPath.
  Description: This test will check the functionality of the method when the input graph has a direct path from source to destination.
Execution:
  Arrange: Create a simple graph with vertices and edges where there is a direct path from source to destination. 
  Act: Invoke the allPathsFromSourceToTarget method with the created graph, source, and destination.
  Assert: Verify that the returned list contains only one path, which is a direct path from source to destination.
Validation: 
  The assertion verifies that the method correctly identifies and returns the direct path from source to destination. This test confirms that the method works correctly for simple graphs.

Scenario 2: Testing allPathsFromSourceToTarget with a complex graph having multiple paths from source to destination.

Details:  
  TestName: testMultiplePaths.
  Description: This test will check the functionality of the method when the input graph has multiple paths from source to destination.
Execution:
  Arrange: Create a complex graph with vertices and edges where there are multiple paths from source to destination. 
  Act: Invoke the allPathsFromSourceToTarget method with the created graph, source, and destination.
  Assert: Verify that the returned list contains all the possible paths from source to destination.
Validation: 
  The assertion verifies that the method correctly identifies and returns all the possible paths from source to destination. This test confirms that the method works correctly for complex graphs.

Scenario 3: Testing allPathsFromSourceToTarget with a graph where the source and destination are the same.

Details:  
  TestName: testSourceAndDestinationSame.
  Description: This test will check the functionality of the method when the source and destination are the same.
Execution:
  Arrange: Create a graph with vertices and edges where the source and destination are the same. 
  Act: Invoke the allPathsFromSourceToTarget method with the created graph, source, and destination.
  Assert: Verify that the returned list contains an empty path, indicating no movement.
Validation: 
  The assertion verifies that the method correctly identifies and returns an empty path when the source and destination are the same. This test confirms that the method handles such edge cases correctly.

Scenario 4: Testing allPathsFromSourceToTarget with a graph where there is no path from source to destination.

Details:  
  TestName: testNoPath.
  Description: This test will check the functionality of the method when there is no path from source to destination in the input graph.
Execution:
  Arrange: Create a graph with vertices and edges where there is no path from source to destination. 
  Act: Invoke the allPathsFromSourceToTarget method with the created graph, source, and destination.
  Assert: Verify that the returned list is empty, indicating no path.
Validation: 
  The assertion verifies that the method correctly returns an empty list when there is no path from source to destination. This test confirms that the method handles such edge cases correctly.
"""
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import java.util.List;
import java.util.ArrayList;

public class AllPathsFromSourceToTargetAllPathsFromSourceToTargetTest {
    @Test
    @Tag("valid")
    public void testDirectPath() {
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(2);
        int[][] edges = new int[][]{{0, 1}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(2, edges, 0, 1);
        assertEquals(1, paths.size());
        assertEquals(List.of(0, 1), paths.get(0));
    }
    @Test
    @Tag("valid")
    public void testMultiplePaths() {
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(4);
        int[][] edges = new int[][]{{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertEquals(2, paths.size());
        assertEquals(List.of(0, 1, 3), paths.get(0));
        assertEquals(List.of(0, 2, 3), paths.get(1));
    }
    @Test
    @Tag("boundary")
    public void testSourceAndDestinationSame() {
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(1);
        int[][] edges = new int[][]{};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(1, edges, 0, 0);
        assertEquals(1, paths.size());
        assertEquals(List.of(0), paths.get(0));
    }
    @Test
    @Tag("invalid")
    public void testNoPath() {
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(2);
        int[][] edges = new int[][]{{0, 1}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(2, edges, 1, 0);
        assertEquals(0, paths.size());
    }
}