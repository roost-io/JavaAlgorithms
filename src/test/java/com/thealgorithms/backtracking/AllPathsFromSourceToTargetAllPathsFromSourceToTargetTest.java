

// ********RoostGPT********
/*
Test generated by RoostGPT for test testmenow using AI Type  and AI Model 

ROOST_METHOD_HASH=allPathsFromSourceToTarget_cbfd384f14
ROOST_METHOD_SIG_HASH=allPathsFromSourceToTarget_5946a30114

Based on the provided information, here are several test scenarios for the `allPathsFromSourceToTarget` method:

```
Scenario 1: Test with a Simple Graph

Details:
  TestName: simpleGraphAllPaths
  Description: Test the method with a simple graph to ensure it correctly identifies all paths from source to destination.

Execution:
  Arrange: Create a simple graph with 4 vertices and edges [(0,1), (0,2), (1,3), (2,3)].
  Act: Call allPathsFromSourceToTarget(4, {{0,1}, {0,2}, {1,3}, {2,3}}, 0, 3).
  Assert: Verify that the returned list contains two paths: [0,1,3] and [0,2,3].

Validation:
  This test verifies that the method correctly identifies all possible paths in a simple graph. It's crucial to ensure the basic functionality works as expected for straightforward cases.

Scenario 2: Test with No Path Between Source and Destination

Details:
  TestName: noPathBetweenSourceAndDestination
  Description: Test the method when there is no path between the source and destination vertices.

Execution:
  Arrange: Create a graph with 4 vertices and edges [(0,1), (2,3)].
  Act: Call allPathsFromSourceToTarget(4, {{0,1}, {2,3}}, 0, 3).
  Assert: Verify that the returned list is empty.

Validation:
  This test ensures that the method correctly handles cases where no path exists between the source and destination. It's important to verify that the method doesn't return invalid paths.

Scenario 3: Test with Source and Destination Being the Same Vertex

Details:
  TestName: sourceAndDestinationSameVertex
  Description: Test the method when the source and destination are the same vertex.

Execution:
  Arrange: Create a graph with 3 vertices and edges [(0,1), (1,2)].
  Act: Call allPathsFromSourceToTarget(3, {{0,1}, {1,2}}, 1, 1).
  Assert: Verify that the returned list contains one path: [1].

Validation:
  This test checks if the method correctly handles the case where the source and destination are the same. It should return a single path containing only that vertex.

Scenario 4: Test with a Cyclic Graph

Details:
  TestName: cyclicGraphAllPaths
  Description: Test the method with a graph containing cycles to ensure it doesn't get stuck in infinite loops.

Execution:
  Arrange: Create a cyclic graph with 4 vertices and edges [(0,1), (1,2), (2,3), (3,1)].
  Act: Call allPathsFromSourceToTarget(4, {{0,1}, {1,2}, {2,3}, {3,1}}, 0, 3).
  Assert: Verify that the returned list contains the correct paths without duplicates or infinite loops.

Validation:
  This test verifies that the method can handle cyclic graphs without getting stuck in infinite recursion. It's crucial for ensuring the robustness of the algorithm.

Scenario 5: Test with a Large Graph

Details:
  TestName: largeGraphAllPaths
  Description: Test the method's performance and correctness with a larger graph.

Execution:
  Arrange: Create a graph with a significant number of vertices and edges (e.g., 100 vertices).
  Act: Call allPathsFromSourceToTarget with the large graph data.
  Assert: Verify that the method returns within a reasonable time and that the returned paths are valid.

Validation:
  This test checks the method's scalability and performance with larger inputs. It's important to ensure the algorithm remains efficient for bigger graphs.

Scenario 6: Test with Invalid Input (Negative Vertex Numbers)

Details:
  TestName: invalidInputNegativeVertices
  Description: Test the method's behavior when given invalid input with negative vertex numbers.

Execution:
  Arrange: Prepare input with negative vertex numbers.
  Act: Call allPathsFromSourceToTarget(-1, {{0,1}}, 0, 1).
  Assert: Verify that the method handles this invalid input appropriately (e.g., throws an exception or returns an empty list).

Validation:
  This test ensures that the method gracefully handles invalid inputs, which is crucial for robust error handling in the application.
```

These test scenarios cover various aspects of the `allPathsFromSourceToTarget` method, including basic functionality, edge cases, and potential error conditions. They aim to ensure the method works correctly across different graph structures and input types.
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import java.util.List;
import java.util.Arrays;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;

class AllPathsFromSourceToTargetAllPathsFromSourceToTargetTest {
    private AllPathsFromSourceToTarget allPathsFromSourceToTarget;
    @BeforeEach
    void setUp() {
        allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(4);
    }
    @Test
    @Tag("valid")
    void simpleGraphAllPaths() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertEquals(2, paths.size());
        assertTrue(paths.contains(Arrays.asList(0, 1, 3)));
        assertTrue(paths.contains(Arrays.asList(0, 2, 3)));
    }
    @Test
    @Tag("valid")
    void noPathBetweenSourceAndDestination() {
        int[][] edges = {{0, 1}, {2, 3}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertTrue(paths.isEmpty());
    }
    @Test
    @Tag("boundary")
    void sourceAndDestinationSameVertex() {
        int[][] edges = {{0, 1}, {1, 2}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 1, 1);
        assertEquals(1, paths.size());
        assertEquals(Arrays.asList(1), paths.get(0));
    }
    @Test
    @Tag("valid")
    void cyclicGraphAllPaths() {
        int[][] edges = {{0, 1}, {1, 2}, {2, 3}, {3, 1}};
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertTrue(paths.contains(Arrays.asList(0, 1, 2, 3)));
        assertFalse(paths.contains(Arrays.asList(0, 1, 2, 3, 1, 2, 3)));
    }
    @Test
    @Tag("valid")
    void largeGraphAllPaths() {
        int[][] edges = new int[100][2];
        for (int i = 0; i < 99; i++) {
            edges[i] = new int[]{i, i + 1};
        }
        long startTime = System.currentTimeMillis();
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(100, edges, 0, 99);
        long endTime = System.currentTimeMillis();
        assertTrue((endTime - startTime) < 5000);
        assertEquals(1, paths.size());
        assertEquals(100, paths.get(0).size());
    }
    @ParameterizedTest
    @MethodSource("invalidInputProvider")
    @Tag("invalid")
    void invalidInput(int vertices, int[][] edges, int source, int destination) {
        assertThrows(IllegalArgumentException.class, () -> 
            AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, edges, source, destination)
        );
    }
    private static Stream<Arguments> invalidInputProvider() {
        return Stream.of(
            Arguments.of(-1, new int[][]{{0, 1}}, 0, 1),
            Arguments.of(2, new int[][]{{0, 2}}, 0, 1),
            Arguments.of(2, new int[][]{{0, 1}}, -1, 1),
            Arguments.of(2, new int[][]{{0, 1}}, 0, 2)
        );
    }
}