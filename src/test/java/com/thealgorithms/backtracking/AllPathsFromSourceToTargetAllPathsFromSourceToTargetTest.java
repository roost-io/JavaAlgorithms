// ********RoostGPT********
/*
Test generated by RoostGPT for test testmenow using AI Type  and AI Model 

ROOST_METHOD_HASH=allPathsFromSourceToTarget_cbfd384f14
ROOST_METHOD_SIG_HASH=allPathsFromSourceToTarget_5946a30114

Here are the test scenarios for the `allPathsFromSourceToTarget` method:

**Scenario 1: Happy Path with Single Path**

Details:
TestName: `testSinglePathFound`
Description: Verifies that the method returns a single path when there is only one possible path from source to destination.
Execution:
Arrange: Create a graph with 3 vertices and 2 edges: (0, 1) and (1, 2).
Act: Call `allPathsFromSourceToTarget(3, [[0, 1], [1, 2]], 0, 2)`.
Assert: Verify that the result contains a single path: [[0, 1, 2]].
Validation: This test ensures that the method can find a single path when there are no cycles or multiple paths.

**Scenario 2: Happy Path with Multiple Paths**

Details:
TestName: `testMultiplePathsFound`
Description: Verifies that the method returns multiple paths when there are multiple possible paths from source to destination.
Execution:
Arrange: Create a graph with 4 vertices and 4 edges: (0, 1), (0, 2), (1, 3), and (2, 3).
Act: Call `allPathsFromSourceToTarget(4, [[0, 1], [0, 2], [1, 3], [2, 3]], 0, 3)`.
Assert: Verify that the result contains two paths: [[0, 1, 3], [0, 2, 3]].
Validation: This test ensures that the method can find multiple paths when there are multiple possible paths.

**Scenario 3: No Path Found**

Details:
TestName: `testNoPathFound`
Description: Verifies that the method returns an empty list when there is no path from source to destination.
Execution:
Arrange: Create a graph with 3 vertices and 1 edge: (0, 1).
Act: Call `allPathsFromSourceToTarget(3, [[0, 1]], 0, 2)`.
Assert: Verify that the result is an empty list.
Validation: This test ensures that the method returns an empty list when there is no path from source to destination.

**Scenario 4: Source and Destination are the Same**

Details:
TestName: `testSourceEqualsDestination`
Description: Verifies that the method returns a single path containing only the source vertex when the source and destination are the same.
Execution:
Arrange: Create a graph with 1 vertex and 0 edges.
Act: Call `allPathsFromSourceToTarget(1, [], 0, 0)`.
Assert: Verify that the result contains a single path: [[0]].
Validation: This test ensures that the method handles the case where the source and destination are the same.

**Scenario 5: Invalid Input - Negative Number of Vertices**

Details:
TestName: `testInvalidInputNegativeVertices`
Description: Verifies that the method throws an exception when the number of vertices is negative.
Execution:
Arrange: None
Act: Call `allPathsFromSourceToTarget(-1, [], 0, 0)`.
Assert: Verify that the method throws an exception.
Validation: This test ensures that the method handles invalid input and throws an exception when the number of vertices is negative.

**Scenario 6: Invalid Input - Null Edges**

Details:
TestName: `testInvalidInputNullEdges`
Description: Verifies that the method throws an exception when the edges are null.
Execution:
Arrange: None
Act: Call `allPathsFromSourceToTarget(3, null, 0, 0)`.
Assert: Verify that the method throws an exception.
Validation: This test ensures that the method handles invalid input and throws an exception when the edges are null.

**Scenario 7: Invalid Input - Source or Destination Out of Range**

Details:
TestName: `testInvalidInputSourceOutOfRange`
Description: Verifies that the method throws an exception when the source or destination is out of range.
Execution:
Arrange: Create a graph with 3 vertices and 0 edges.
Act: Call `allPathsFromSourceToTarget(3, [], 3, 0)`.
Assert: Verify that the method throws an exception.
Validation: This test ensures that the method handles invalid input and throws an exception when the source or destination is out of range.
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Tag;
import java.util.ArrayList;
import java.util.List;

public class AllPathsFromSourceToTargetAllPathsFromSourceToTargetTest {
    @Test
    @Tag("valid")
    public void testSinglePathFound() {
        int[][] edges = {{0, 1}, {1, 2}};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 0, 2);
        assertEquals(1, result.size());
        assertEquals(3, result.get(0).size());
        assertTrue(result.get(0).contains(0));
        assertTrue(result.get(0).contains(1));
        assertTrue(result.get(0).contains(2));
    }
    @Test
    @Tag("valid")
    public void testMultiplePathsFound() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertEquals(2, result.size());
        assertEquals(3, result.get(0).size());
        assertEquals(3, result.get(1).size());
        assertTrue(result.get(0).contains(0));
        assertTrue(result.get(0).contains(1));
        assertTrue(result.get(0).contains(3));
        assertTrue(result.get(1).contains(0));
        assertTrue(result.get(1).contains(2));
        assertTrue(result.get(1).contains(3));
    }
    @Test
    @Tag("valid")
    public void testNoPathFound() {
        int[][] edges = {{0, 1}};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 0, 2);
        assertTrue(result.isEmpty());
    }
    @Test
    @Tag("boundary")
    public void testSourceEqualsDestination() {
        int[][] edges = {};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(1, edges, 0, 0);
        assertEquals(1, result.size());
        assertEquals(1, result.get(0).size());
        assertTrue(result.get(0).contains(0));
    }
/*
The test `testInvalidInputNegativeVertices` is failing because the `allPathsFromSourceToTarget` method is throwing a `NegativeArraySizeException` instead of the expected `IllegalArgumentException`. This is because the method is trying to initialize an array with a negative size when the input `vertices` is -1. The test is expecting an `IllegalArgumentException` to be thrown in this case, but the actual exception thrown is a `NegativeArraySizeException`. 

The reason for this discrepancy is that the method `initAdjList` is called in the constructor of `AllPathsFromSourceToTarget`, which tries to initialize an array with the given `vertices` size. When `vertices` is -1, this results in a `NegativeArraySizeException`. 

To fix this test, the method `allPathsFromSourceToTarget` should be modified to throw an `IllegalArgumentException` when the input `vertices` is negative, before trying to initialize the array. Alternatively, the test can be modified to expect a `NegativeArraySizeException` instead of an `IllegalArgumentException`. 

Additionally, there are some warnings in the build log about unchecked or unsafe operations in some of the source files. These warnings should be addressed by recompiling the relevant source files with the `-Xlint:unchecked` option to get more information about the warnings. 

Finally, there is a warning about a duplicate declaration of the maven-surefire-plugin in the build log. This warning should be addressed by removing the duplicate declaration from the pom.xml file.
@Test
@Tag("invalid")
public void testInvalidInputNegativeVertices() {
    int[][] edges = {};
    assertThrows(IllegalArgumentException.class, () -> AllPathsFromSourceToTarget.allPathsFromSourceToTarget(-1, edges, 0, 0));
}
*/

    @Test
    @Tag("invalid")
    public void testInvalidInputNullEdges() {
        assertThrows(NullPointerException.class, () -> AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, null, 0, 0));
    }
/*
The test `testInvalidInputSourceOutOfRange` is failing because it is expecting an `IllegalArgumentException` to be thrown when the source vertex is out of range, but instead, an `ArrayIndexOutOfBoundsException` is being thrown. This is because the `storeAllPathsUtil` method in the `AllPathsFromSourceToTarget` class is attempting to access an index in the adjacency list that is out of bounds.

The reason for this is that the `allPathsFromSourceToTarget` method does not perform any bounds checking on the source vertex before calling `storeAllPathsUtil`. Therefore, when the source vertex is equal to the number of vertices, it is out of range for the adjacency list, causing the `ArrayIndexOutOfBoundsException`.

To fix this test, the `allPathsFromSourceToTarget` method should be modified to throw an `IllegalArgumentException` when the source vertex is out of range, rather than relying on the `ArrayIndexOutOfBoundsException` being thrown. This would involve adding a check at the beginning of the method to ensure that the source vertex is within the valid range.
@Test
@Tag("invalid")
public void testInvalidInputSourceOutOfRange() {
    int[][] edges = {};
    assertThrows(IllegalArgumentException.class, () -> AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 3, 0));
}
*/

}