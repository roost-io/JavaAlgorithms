

// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=allPathsFromSourceToTarget_cbfd384f14
ROOST_METHOD_SIG_HASH=allPathsFromSourceToTarget_5946a30114

Scenario 1: Test with valid vertices and edges
Details:  
  TestName: testValidVerticesAndEdges.
  Description: This test is meant to check if the method is able to correctly compute all possible paths from source to destination with valid vertices and edges. 
Execution:
  Arrange: Set up a graph with a certain number of vertices and edges.
  Act: Invoke allPathsFromSourceToTarget with the appropriate number of vertices, edges, source, and destination.
  Assert: Use JUnit assertions to compare the actual list of paths against the expected list of paths.
Validation: 
  The assertion aims to verify that the method is able to correctly compute all possible paths from source to destination. The expected result is based on our understanding of the graph and the paths from source to destination. This test is significant because it validates the basic functionality of the method.

Scenario 2: Test with no valid path from source to destination
Details:  
  TestName: testNoValidPath.
  Description: This test is meant to check if the method is able to handle the scenario where there is no valid path from source to destination.
Execution:
  Arrange: Set up a graph with a certain number of vertices and edges such that there is no valid path from source to destination.
  Act: Invoke allPathsFromSourceToTarget with the appropriate number of vertices, edges, source, and destination.
  Assert: Use JUnit assertions to compare the actual list of paths (which should be empty) against the expected list of paths (which is also empty).
Validation: 
  The assertion aims to verify that the method is able to handle the scenario where there is no valid path from source to destination. The expected result is an empty list of paths. This test is significant because it tests the method's robustness in handling edge cases.

Scenario 3: Test with source equals to destination
Details:  
  TestName: testSourceEqualsToDestination.
  Description: This test is meant to check if the method can handle the scenario where the source is the same as the destination.
Execution:
  Arrange: Set up a graph with a certain number of vertices and edges.
  Act: Invoke allPathsFromSourceToTarget with the source being the same as the destination.
  Assert: Use JUnit assertions to compare the actual list of paths (which should contain only one path, i.e., the source/destination itself) against the expected list of paths.
Validation: 
  The assertion aims to verify that the method can handle the scenario where the source is the same as the destination. The expected result is a list containing only one path, which is the source/destination itself. This test is significant because it tests the method's ability to handle special cases.

Scenario 4: Test with invalid vertices
Details:  
  TestName: testInvalidVertices.
  Description: This test is meant to check if the method can handle the scenario where the input vertices are invalid (either negative or exceeding the number of vertices in the graph).
Execution:
  Arrange: Set up a graph with a certain number of vertices and edges.
  Act: Invoke allPathsFromSourceToTarget with invalid vertices.
  Assert: Expect an exception to be thrown.
Validation: 
  The assertion aims to verify that the method can handle invalid input appropriately. The expected result is an exception. This test is significant because it tests the method's error handling ability.
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class AllPathsFromSourceToTargetAllPathsFromSourceToTargetTest {
    @Test
    @Tag("valid")
    public void testValidVerticesAndEdges() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        List<List<Integer>> expected = new ArrayList<>();
        expected.add(Arrays.asList(0, 1, 3));
        expected.add(Arrays.asList(0, 2, 3));
        assertEquals(expected, AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3));
    }
    @Test
    @Tag("invalid")
    public void testNoValidPath() {
        int[][] edges = {{0, 1}, {1, 2}, {2, 3}, {3, 4}};
        List<List<Integer>> expected = new ArrayList<>();
        assertEquals(expected, AllPathsFromSourceToTarget.allPathsFromSourceToTarget(5, edges, 0, 5));
    }
    @Test
    @Tag("valid")
    public void testSourceEqualsToDestination() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        List<List<Integer>> expected = new ArrayList<>();
        expected.add(Arrays.asList(0));
        assertEquals(expected, AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 0));
    }
    @Test
    @Tag("invalid")
    public void testInvalidVertices() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        assertThrows(IllegalArgumentException.class, () -> {
            AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, -1);
        });
    }
}