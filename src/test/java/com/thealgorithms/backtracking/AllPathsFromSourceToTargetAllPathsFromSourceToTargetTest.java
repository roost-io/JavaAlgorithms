// ********RoostGPT********
/*
Test generated by RoostGPT for test testmenow using AI Type  and AI Model 

ROOST_METHOD_HASH=allPathsFromSourceToTarget_cbfd384f14
ROOST_METHOD_SIG_HASH=allPathsFromSourceToTarget_5946a30114

Here are the test scenarios for the `allPathsFromSourceToTarget` method:

**Scenario 1: Happy Path with Single Path**

Details:
TestName: `testSinglePathFound`
Description: Verifies that the method returns a single path when there is only one possible path from source to destination.
Execution:
Arrange: Create a graph with 3 vertices and 2 edges: (0, 1) and (1, 2).
Act: Call `allPathsFromSourceToTarget(3, [[0, 1], [1, 2]], 0, 2)`.
Assert: Verify that the result contains a single path: [[0, 1, 2]].
Validation: This test ensures that the method can find a single path when there are no cycles or multiple paths.

**Scenario 2: Happy Path with Multiple Paths**

Details:
TestName: `testMultiplePathsFound`
Description: Verifies that the method returns multiple paths when there are multiple possible paths from source to destination.
Execution:
Arrange: Create a graph with 4 vertices and 4 edges: (0, 1), (0, 2), (1, 3), and (2, 3).
Act: Call `allPathsFromSourceToTarget(4, [[0, 1], [0, 2], [1, 3], [2, 3]], 0, 3)`.
Assert: Verify that the result contains two paths: [[0, 1, 3], [0, 2, 3]].
Validation: This test ensures that the method can find multiple paths when there are multiple possible paths.

**Scenario 3: No Path Found**

Details:
TestName: `testNoPathFound`
Description: Verifies that the method returns an empty list when there is no path from source to destination.
Execution:
Arrange: Create a graph with 3 vertices and 1 edge: (0, 1).
Act: Call `allPathsFromSourceToTarget(3, [[0, 1]], 0, 2)`.
Assert: Verify that the result is an empty list.
Validation: This test ensures that the method returns an empty list when there is no path from source to destination.

**Scenario 4: Source and Destination are the Same**

Details:
TestName: `testSourceEqualsDestination`
Description: Verifies that the method returns a single path containing only the source vertex when the source and destination are the same.
Execution:
Arrange: Create a graph with 1 vertex and 0 edges.
Act: Call `allPathsFromSourceToTarget(1, [], 0, 0)`.
Assert: Verify that the result contains a single path: [[0]].
Validation: This test ensures that the method handles the case where the source and destination are the same.

**Scenario 5: Invalid Input - Negative Number of Vertices**

Details:
TestName: `testInvalidInputNegativeVertices`
Description: Verifies that the method throws an exception when the number of vertices is negative.
Execution:
Arrange: None
Act: Call `allPathsFromSourceToTarget(-1, [], 0, 0)`.
Assert: Verify that the method throws an exception.
Validation: This test ensures that the method handles invalid input and throws an exception when the number of vertices is negative.

**Scenario 6: Invalid Input - Null Edges**

Details:
TestName: `testInvalidInputNullEdges`
Description: Verifies that the method throws an exception when the edges are null.
Execution:
Arrange: None
Act: Call `allPathsFromSourceToTarget(3, null, 0, 0)`.
Assert: Verify that the method throws an exception.
Validation: This test ensures that the method handles invalid input and throws an exception when the edges are null.

**Scenario 7: Invalid Input - Source or Destination Out of Range**

Details:
TestName: `testInvalidInputSourceOutOfRange`
Description: Verifies that the method throws an exception when the source or destination is out of range.
Execution:
Arrange: Create a graph with 3 vertices and 0 edges.
Act: Call `allPathsFromSourceToTarget(3, [], 3, 0)`.
Assert: Verify that the method throws an exception.
Validation: This test ensures that the method handles invalid input and throws an exception when the source or destination is out of range.
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Tag;
import java.util.ArrayList;
import java.util.List;

public class AllPathsFromSourceToTargetAllPathsFromSourceToTargetTest {
    @Test
    @Tag("valid")
    public void testSinglePathFound() {
        int[][] edges = {{0, 1}, {1, 2}};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 0, 2);
        assertEquals(1, result.size());
        assertEquals(3, result.get(0).size());
        assertTrue(result.get(0).contains(0));
        assertTrue(result.get(0).contains(1));
        assertTrue(result.get(0).contains(2));
    }
    @Test
    @Tag("valid")
    public void testMultiplePathsFound() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertEquals(2, result.size());
        assertEquals(3, result.get(0).size());
        assertEquals(3, result.get(1).size());
        assertTrue(result.get(0).contains(0));
        assertTrue(result.get(0).contains(1));
        assertTrue(result.get(0).contains(3));
        assertTrue(result.get(1).contains(0));
        assertTrue(result.get(1).contains(2));
        assertTrue(result.get(1).contains(3));
    }
    @Test
    @Tag("valid")
    public void testNoPathFound() {
        int[][] edges = {{0, 1}};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 0, 2);
        assertTrue(result.isEmpty());
    }
    @Test
    @Tag("boundary")
    public void testSourceEqualsDestination() {
        int[][] edges = {};
        List<List<Integer>> result = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(1, edges, 0, 0);
        assertEquals(1, result.size());
        assertEquals(1, result.get(0).size());
        assertTrue(result.get(0).contains(0));
    }
    @Test
    @Tag("invalid")
    public void testInvalidInputNegativeVertices() {
        int[][] edges = {};
        assertThrows(IllegalArgumentException.class, () -> AllPathsFromSourceToTarget.allPathsFromSourceToTarget(-1, edges, 0, 0));
    }
    @Test
    @Tag("invalid")
    public void testInvalidInputNullEdges() {
        assertThrows(NullPointerException.class, () -> AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, null, 0, 0));
    }
    @Test
    @Tag("invalid")
    public void testInvalidInputSourceOutOfRange() {
        int[][] edges = {};
        assertThrows(IllegalArgumentException.class, () -> AllPathsFromSourceToTarget.allPathsFromSourceToTarget(3, edges, 3, 0));
    }
}