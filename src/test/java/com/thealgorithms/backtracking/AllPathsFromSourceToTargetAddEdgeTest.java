

// ********RoostGPT********
/*
Test generated by RoostGPT for test testmenow using AI Type  and AI Model 

ROOST_METHOD_HASH=addEdge_e27d54ea18
ROOST_METHOD_SIG_HASH=addEdge_d5a8294674

Based on the provided information and the method `addEdge`, here are several test scenarios for the `AllPathsFromSourceToTarget` class:

```
Scenario 1: Add Edge to Empty Graph

Details:
  TestName: addEdgeToEmptyGraph
  Description: Test adding an edge to an empty graph with no existing edges.
Execution:
  Arrange: Create a new AllPathsFromSourceToTarget object with a small number of vertices (e.g., 3).
  Act: Call addEdge(0, 1) to add an edge from vertex 0 to vertex 1.
  Assert: Verify that the edge has been added correctly by calling allPathsFromSourceToTarget and checking the result.
Validation:
  This test ensures that the addEdge method correctly adds an edge to an empty graph. It's important to verify that the basic functionality works in the simplest case.

Scenario 2: Add Multiple Edges

Details:
  TestName: addMultipleEdges
  Description: Test adding multiple edges to the graph and verify all are added correctly.
Execution:
  Arrange: Create a new AllPathsFromSourceToTarget object with a moderate number of vertices (e.g., 5).
  Act: Call addEdge multiple times to add several edges (e.g., (0,1), (1,2), (2,3), (3,4)).
  Assert: Use allPathsFromSourceToTarget to verify that all paths from 0 to 4 are correctly identified.
Validation:
  This test checks if the addEdge method can handle multiple edge additions and if the graph structure is maintained correctly for path finding.

Scenario 3: Add Duplicate Edge

Details:
  TestName: addDuplicateEdge
  Description: Test adding the same edge twice to ensure it doesn't create duplicates.
Execution:
  Arrange: Create a new AllPathsFromSourceToTarget object.
  Act: Call addEdge(0, 1) twice.
  Assert: Use allPathsFromSourceToTarget to verify that only one path exists from 0 to 1.
Validation:
  This test ensures that adding the same edge multiple times doesn't create duplicate edges in the graph, which could lead to incorrect path calculations.

Scenario 4: Add Self-Loop

Details:
  TestName: addSelfLoop
  Description: Test adding an edge from a vertex to itself (self-loop).
Execution:
  Arrange: Create a new AllPathsFromSourceToTarget object.
  Act: Call addEdge(0, 0) to add a self-loop.
  Assert: Use allPathsFromSourceToTarget to verify that the self-loop is correctly represented in the paths.
Validation:
  This test checks if the addEdge method correctly handles self-loops, which are valid in some graph problems and should be properly represented.

Scenario 5: Add Edge with Invalid Vertex

Details:
  TestName: addEdgeWithInvalidVertex
  Description: Test adding an edge with a vertex number that exceeds the graph size.
Execution:
  Arrange: Create a new AllPathsFromSourceToTarget object with a specific number of vertices (e.g., 3).
  Act: Attempt to call addEdge(2, 4), where 4 is out of bounds.
  Assert: Expect an IndexOutOfBoundsException to be thrown.
Validation:
  This test verifies that the addEdge method properly handles attempts to add edges with invalid vertex numbers, which is crucial for maintaining the integrity of the graph structure.

Scenario 6: Add Edges to Create Cyclic Graph

Details:
  TestName: addEdgesToCreateCyclicGraph
  Description: Test adding edges that create a cycle in the graph.
Execution:
  Arrange: Create a new AllPathsFromSourceToTarget object with at least 3 vertices.
  Act: Call addEdge to create a cycle (e.g., (0,1), (1,2), (2,0)).
  Assert: Use allPathsFromSourceToTarget to verify that all cyclic paths are correctly identified.
Validation:
  This test ensures that the addEdge method correctly handles the creation of cyclic graphs, which is important for algorithms that need to detect or work with cycles.
```

These test scenarios cover various aspects of the `addEdge` method, including basic functionality, edge cases, and potential error conditions. They aim to ensure that the method behaves correctly in different situations and maintains the graph structure as expected.
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.List;

class AllPathsFromSourceToTargetAddEdgeTest {
    private AllPathsFromSourceToTarget graph;
    @BeforeEach
    void setUp() {
        graph = new AllPathsFromSourceToTarget(5);
    }
    @Test
    @Tag("valid")
    void addEdgeToEmptyGraph() {
        graph.addEdge(0, 1);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(5, new int[][]{{0, 1}}, 0, 1);
        assertEquals(1, paths.size());
        assertEquals(List.of(0, 1), paths.get(0));
    }
    @Test
    @Tag("valid")
    void addMultipleEdges() {
        graph.addEdge(0, 1);
        graph.addEdge(1, 2);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(5, new int[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}}, 0, 4);
        assertEquals(1, paths.size());
        assertEquals(List.of(0, 1, 2, 3, 4), paths.get(0));
    }
    @Test
    @Tag("valid")
    void addDuplicateEdge() {
        graph.addEdge(0, 1);
        graph.addEdge(0, 1);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(5, new int[][]{{0, 1}, {0, 1}}, 0, 1);
        assertEquals(1, paths.size());
        assertEquals(List.of(0, 1), paths.get(0));
    }
    @Test
    @Tag("valid")
    void addSelfLoop() {
        graph.addEdge(0, 0);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(5, new int[][]{{0, 0}}, 0, 0);
        assertEquals(1, paths.size());
        assertEquals(List.of(0), paths.get(0));
    }
    @Test
    @Tag("invalid")
    void addEdgeWithInvalidVertex() {
        assertThrows(IndexOutOfBoundsException.class, () -> graph.addEdge(2, 5));
    }
    @Test
    @Tag("valid")
    void addEdgesToCreateCyclicGraph() {
        graph.addEdge(0, 1);
        graph.addEdge(1, 2);
        graph.addEdge(2, 0);
        List<List<Integer>> paths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(5, new int[][]{{0, 1}, {1, 2}, {2, 0}}, 0, 2);
        assertEquals(2, paths.size());
        assertTrue(paths.contains(List.of(0, 1, 2)));
        assertTrue(paths.contains(List.of(0, 1, 2, 0, 1, 2)));
    }
}