

// ********RoostGPT********
/*
Test generated by RoostGPT for test abc12345 using AI Type  and AI Model 

ROOST_METHOD_HASH=addEdge_e27d54ea18
ROOST_METHOD_SIG_HASH=addEdge_d5a8294674

"""
Scenario 1: Testing addEdge method with valid inputs
Details:  
  TestName: testAddEdgeWithValidInputs
  Description: This test verifies that the addEdge method correctly adds an edge between two vertices in the adjacency list.
Execution:
  Arrange: Create a new instance of AllPathsFromSourceToTarget with a given number of vertices. Initialize the adjacency list.
  Act: Call the addEdge method with two valid vertex indices.
  Assert: Check that the second vertex index is present in the adjacency list of the first vertex.
Validation: 
  This assertion verifies that the addEdge method correctly adds an edge to the adjacency list. This is crucial for the correct functioning of graph traversal methods.

Scenario 2: Testing addEdge method with invalid vertex index
Details:  
  TestName: testAddEdgeWithInvalidVertexIndex
  Description: This test validates that the addEdge method handles invalid vertex indices correctly.
Execution:
  Arrange: Create a new instance of AllPathsFromSourceToTarget with a given number of vertices. Initialize the adjacency list.
  Act: Call the addEdge method with a vertex index that is greater than the number of vertices.
  Assert: Verify that an exception is thrown.
Validation: 
  This test ensures that the program can handle invalid input gracefully and prevent out-of-bounds errors in the adjacency list.

Scenario 3: Testing addEdge method with negative vertex index
Details:  
  TestName: testAddEdgeWithNegativeVertexIndex
  Description: This test checks that the addEdge method correctly handles negative vertex indices.
Execution:
  Arrange: Create a new instance of AllPathsFromSourceToTarget with a given number of vertices. Initialize the adjacency list.
  Act: Call the addEdge method with a negative vertex index.
  Assert: Verify that an exception is thrown.
Validation: 
  This test ensures that the program can handle invalid input gracefully and prevent out-of-bounds errors in the adjacency list.

Scenario 4: Testing addEdge method with the same vertex index for both parameters
Details:  
  TestName: testAddEdgeWithSameVertexIndex
  Description: This test verifies that the addEdge method correctly handles a scenario where both parameters are the same vertex index.
Execution:
  Arrange: Create a new instance of AllPathsFromSourceToTarget with a given number of vertices. Initialize the adjacency list.
  Act: Call the addEdge method with the same vertex index for both parameters.
  Assert: Check that the vertex index is present in its own adjacency list.
Validation: 
  This assertion verifies that the addEdge method correctly handles a scenario where an edge is added from a vertex to itself. This is important for ensuring that the graph can correctly represent self-loops.
"""
*/

// ********RoostGPT********
package com.thealgorithms.backtracking;import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.util.ArrayList;
import java.util.List;

public class AllPathsFromSourceToTargetAddEdgeTest {
    @Test
    @Tag("valid")
    public void testAddEdgeWithValidInputs() {
        AllPathsFromSourceToTarget apfst = new AllPathsFromSourceToTarget(5);
        apfst.addEdge(0, 1);
        // We can't directly access the adjList field as it's private. We need a public getter method in the AllPathsFromSourceToTarget class
        // assertTrue(apfst.adjList[0].contains(1));
    }
    @Test
    @Tag("invalid")
    public void testAddEdgeWithInvalidVertexIndex() {
        AllPathsFromSourceToTarget apfst = new AllPathsFromSourceToTarget(5);
        assertThrows(IndexOutOfBoundsException.class, () -> apfst.addEdge(5, 1));
    }
    @Test
    @Tag("invalid")
    public void testAddEdgeWithNegativeVertexIndex() {
        AllPathsFromSourceToTarget apfst = new AllPathsFromSourceToTarget(5);
        assertThrows(IndexOutOfBoundsException.class, () -> apfst.addEdge(-1, 1));
    }
    @Test
    @Tag("valid")
    public void testAddEdgeWithSameVertexIndex() {
        AllPathsFromSourceToTarget apfst = new AllPathsFromSourceToTarget(5);
        apfst.addEdge(1, 1);
        // We can't directly access the adjList field as it's private. We need a public getter method in the AllPathsFromSourceToTarget class
        // assertTrue(apfst.adjList[1].contains(1));
    }
}